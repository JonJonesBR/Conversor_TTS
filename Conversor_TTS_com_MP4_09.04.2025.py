import html2text
from bs4 import BeautifulSoup

# === In√≠cio da integra√ß√£o do m√≥dulo de formata√ß√£o ===
import re

def padronizar_capitulos(texto):
    conversao_manual = {
        'UM': 1, 'UMI': 2, 'UMII': 3, 'UMIII': 4, 'UMIV': 5, 'UMV': 6, 'UMVI': 7,
        'CINCO': 5, 'CINCOI': 6, 'CINCOII': 7, 'CINCOIII': 8, 'CINCOIV': 9, 'CINCOV': 10,
        'UMX': 9, 'DEZ': 10, 'DEZI': 11, 'ONZE': 11, 'DOZE': 12
    }

    def substituidor(match):
        capitulo = match.group(1).strip().upper()
        titulo = match.group(2).strip()
        numero = conversao_manual.get(capitulo, capitulo)
        return f"CAP√çTULO {numero}: {titulo.title()}"

    padrao = re.compile(r'CAP[I√ç]TULO\s+([A-Z0-9]+)\s*[:\-]?\s*(.+)', re.IGNORECASE)
    texto_formatado = padrao.sub(substituidor, texto)
    return texto_formatado

def normalizar_caixa(texto):
    linhas = texto.splitlines()
    texto_final = []
    for linha in linhas:
        if linha.isupper() and len(linha.strip()) > 3:
            texto_final.append(linha.capitalize())
        else:
            texto_final.append(linha)
    return "\n".join(texto_final)

def separar_capitulos(texto):
    """
    Ajusta a marca√ß√£o dos cap√≠tulos para:
    'Cap√≠tulo 1.' (com ponto final e duas quebras de linha antes e depois).
    """
    return re.sub(
        r'(CAP[I√ç]TULO\s+\d+)(:)?',
        lambda m: f"\n\n{m.group(1).upper()}.\n\n",
        texto,
        flags=re.IGNORECASE
    )
    return "\n".join([
        f"{match.group(1)}. {match.group(2).title()}" for match in padrao.finditer(texto)
    ])

def remover_numeracao_avulsa(texto):
    """
    Remove numera√ß√µes isoladas no in√≠cio de linhas (como n√∫meros de p√°gina ou listas n√£o desejadas).
    """
    linhas = texto.splitlines()
    novas_linhas = []
    for linha in linhas:
        if re.match(r'^\s*\d+\s*$', linha):  # Linha cont√©m apenas n√∫meros (possivelmente p√°gina)
            continue
        novas_linhas.append(linha)
    return '\n'.join(novas_linhas)

def aplicar_formatacao(texto):
    texto = remover_numeracao_avulsa(texto)
    texto = padronizar_capitulos(texto)
    texto = normalizar_caixa(texto)
    
    # Remover quebras de linha excessivas (exceto ap√≥s pontos finais)
    texto = re.sub(r'(?<!\n)\n(?!\n|\.\s*)', ' ', texto)  # Remove quebras de linha √∫nicas
    texto = re.sub(r'\n{3,}', '\n\n', texto)  # Limita m√∫ltiplas quebras para no m√°ximo duas
    
    # Garantir que haja quebras de linha apenas ap√≥s pontos finais
    texto = re.sub(r'\.\s+', '.\n\n', texto)  # Quebra ap√≥s pontos finais
    
    texto = separar_capitulos(texto)
    return texto


# === Fim da integra√ß√£o ===

#!/usr/bin/env python3
import os
import sys
import subprocess
import asyncio
import re
import signal
from pathlib import Path
import select
import platform
import zipfile
import shutil
import time
import unicodedata
import edge_tts
import aioconsole
import chardet
from math import ceil

# ================== CONFIGURA√á√ïES GLOBAIS ==================

# Tenta importar o tqdm; se n√£o encontrar, instala-o e adiciona o diret√≥rio do usu√°rio ao sys.path
try:
    from tqdm import tqdm
except ModuleNotFoundError:
    print("‚ö†Ô∏è M√≥dulo 'tqdm' n√£o encontrado. Instalando...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "--user", "tqdm"])
    try:
        import site
        site.addsitedir(site.getusersitepackages())
    except Exception as e:
        print(f"‚ùå Erro ao adicionar o diret√≥rio de pacotes do usu√°rio: {e}")
    from tqdm import tqdm

# Garantindo o m√≥dulo requests
try:
    import requests
except ModuleNotFoundError:
    print("‚ö†Ô∏è M√≥dulo 'requests' n√£o encontrado. Instalando...")
    subprocess.check_call([sys.executable, "-m", "pip", "install", "--user", "requests"])
    import requests

# Vozes dispon√≠veis para convers√£o
VOZES_PT_BR = [
    "pt-BR-ThalitaMultilingualNeural",  # Voz padr√£o
    "pt-BR-FranciscaNeural",
    "pt-BR-AntonioNeural"
]

ENCODINGS_TENTATIVAS = ['utf-8', 'utf-16', 'iso-8859-1', 'cp1252']
BUFFER_IO = 32768
MAX_TENTATIVAS = 3  # N√∫mero m√°ximo de tentativas por chunk
CANCELAR_PROCESSAMENTO = False
FFMPEG_BIN = "ffmpeg"
FFPROBE_BIN = "ffprobe"
LIMITE_SEGUNDOS = 43200  # 12 horas para divis√£o de arquivos longos

# ================== FUN√á√ïES DE UTILIDADE E SISTEMA ==================

def handler_sinal(signum, frame):
    global CANCELAR_PROCESSAMENTO
    CANCELAR_PROCESSAMENTO = True
    print("\nüö´ Opera√ß√£o cancelada pelo usu√°rio")

signal.signal(signal.SIGINT, handler_sinal)

def detectar_sistema():
    """Detecta o sistema operacional e ambiente de execu√ß√£o."""
    sistema = {
        'nome': platform.system().lower(),
        'termux': False,
        'android': False,
        'windows': False,
        'linux': False,
        'macos': False,
    }
    if sistema['nome'] == 'windows':
        sistema['windows'] = True
        return sistema
    if sistema['nome'] == 'darwin':
        sistema['macos'] = True
        return sistema
    if sistema['nome'] == 'linux':
        sistema['linux'] = True
        is_android = any([
            'ANDROID_ROOT' in os.environ,
            'TERMUX_VERSION' in os.environ,
            os.path.exists('/data/data/com.termux'),
            os.path.exists('/system/bin/linker64')
        ])
        if is_android:
            sistema['android'] = True
            if any([
                'TERMUX_VERSION' in os.environ,
                os.path.exists('/data/data/com.termux')
            ]):
                sistema['termux'] = True
                os.environ['PATH'] = f"{os.environ.get('PATH', '')}:/data/data/com.termux/files/usr/bin"
    return sistema

def instalar_poppler_windows():
    """Instala o Poppler no Windows automaticamente."""
    try:
        poppler_url = "https://github.com/oschwartz10612/poppler-windows/releases/download/v23.11.0-0/Release-23.11.0-0.zip"
        install_dir = os.path.join(os.environ['LOCALAPPDATA'], 'Poppler')
        os.makedirs(install_dir, exist_ok=True)
        print("üì• Baixando Poppler...")
        response = requests.get(poppler_url)
        zip_path = os.path.join(install_dir, "poppler.zip")
        with open(zip_path, 'wb') as f:
            f.write(response.content)
        print("üì¶ Extraindo arquivos...")
        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            zip_ref.extractall(install_dir)
        os.remove(zip_path)
        bin_paths = [
            os.path.join(install_dir, 'bin'),
            os.path.join(install_dir, 'Library', 'bin'),
            os.path.join(install_dir, 'poppler-23.11.0', 'bin'),
            os.path.join(install_dir, 'Release-23.11.0-0', 'bin')
        ]
        bin_path = None
        for path in bin_paths:
            if os.path.exists(path) and any(f.endswith('.exe') for f in os.listdir(path) if os.path.isfile(os.path.join(path, f))):
                bin_path = path
                break
        if not bin_path:
            for root, dirs, files in os.walk(install_dir):
                if 'bin' in dirs and any(f.endswith('.exe') for f in os.listdir(os.path.join(root, 'bin')) if os.path.isfile(os.path.join(root, 'bin', f))):
                    bin_path = os.path.join(root, 'bin')
                    break
        if not bin_path:
            print(f"‚ùå Erro: Diret√≥rio bin n√£o encontrado em {install_dir}")
            return False
        print(f"‚úÖ Diret√≥rio bin encontrado em: {bin_path}")
        pdftotext_path = os.path.join(bin_path, 'pdftotext.exe')
        if not os.path.exists(pdftotext_path):
            print(f"‚ùå Erro: pdftotext.exe n√£o encontrado em {bin_path}")
            return False
        if bin_path not in os.environ['PATH']:
            os.environ['PATH'] = f"{bin_path};{os.environ['PATH']}"
        try:
            subprocess.run([pdftotext_path, "-v"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
            print("‚úÖ Poppler instalado com sucesso!")
            return True
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Erro ao verificar pdftotext: {e}")
            return False
    except Exception as e:
        print(f"‚ùå Erro ao instalar Poppler: {str(e)}")
        return False

def converter_pdf(caminho_pdf: str, caminho_txt: str) -> bool:
    """Converte PDF para TXT utilizando o comando pdftotext."""
    try:
        caminho_pdf = os.path.abspath(caminho_pdf)
        if not os.path.isfile(caminho_pdf):
            print(f"‚ùå Arquivo PDF n√£o encontrado: {caminho_pdf}")
            return False
        with open(caminho_pdf, 'rb') as _:
            pass
    except PermissionError:
        print(f"‚ùå Sem permiss√£o para acessar o arquivo: {caminho_pdf}")
        return False
    except Exception as e:
        print(f"‚ùå Erro ao acessar o arquivo PDF: {str(e)}")
        return False
    diretorio_saida = os.path.dirname(caminho_txt)
    if diretorio_saida and not os.path.exists(diretorio_saida):
        try:
            os.makedirs(diretorio_saida, exist_ok=True)
            print(f"‚úÖ Diret√≥rio de sa√≠da criado: {diretorio_saida}")
        except Exception as e:
            print(f"‚ùå Erro ao criar diret√≥rio de sa√≠da: {str(e)}")
            return False
    sistema = detectar_sistema()
    if sistema['windows']:
        pdftotext_path = None
        for path in os.environ['PATH'].split(';'):
            if not path.strip():
                continue
            test_path = os.path.join(path.strip(), 'pdftotext.exe')
            if os.path.exists(test_path) and os.path.isfile(test_path):
                pdftotext_path = test_path
                break
        if not pdftotext_path:
            print("üì¶ Poppler n√£o encontrado. Iniciando instala√ß√£o autom√°tica...")
            if not instalar_poppler_windows():
                return False
            for path in os.environ['PATH'].split(';'):
                if not path.strip():
                    continue
                test_path = os.path.join(path.strip(), 'pdftotext.exe')
                if os.path.exists(test_path) and os.path.isfile(test_path):
                    pdftotext_path = test_path
                    break
            if not pdftotext_path:
                print("‚ùå N√£o foi poss√≠vel encontrar o pdftotext mesmo ap√≥s a instala√ß√£o")
                return False
    else:
        try:
            subprocess.run(["pdftotext", "-v"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        except FileNotFoundError:
            if sistema['macos']:
                print("‚ùå O pdftotext n√£o est√° instalado no sistema. Instale com: brew install poppler")
                return False
            elif sistema['linux']:
                if sistema['termux']:
                    print("‚ùå O pdftotext n√£o est√° instalado no sistema. Tentando instalar automaticamente com: pkg install poppler")
                    if instalar_poppler():
                        print("‚úÖ Poppler instalado com sucesso! Execute novamente a convers√£o.")
                    else:
                        print("‚ùå Falha ao instalar poppler automaticamente.")
                    return False
                else:
                    print("‚ùå O pdftotext n√£o est√° instalado no sistema. Instale com: sudo apt-get install poppler-utils")
                    return False
    if sistema['windows'] and pdftotext_path:
        resultado = subprocess.run(
            [pdftotext_path, "-layout", caminho_pdf, caminho_txt],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
    else:
        resultado = subprocess.run(
            ["pdftotext", "-layout", caminho_pdf, caminho_txt],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE
        )
    if resultado.returncode != 0:
        print(f"‚ùå Erro ao converter o PDF: {resultado.stderr.decode()}")
        return False
    return True

def verificar_sistema() -> dict:
    """Exibe informa√ß√µes do ambiente de execu√ß√£o."""
    print("\nüîç Verificando ambiente de execu√ß√£o...")
    sistema = detectar_sistema()
    if sistema['termux']:
        print("‚úÖ Executando no Termux (Android)")
    elif sistema['android']:
        print("‚úÖ Executando no Android (n√£o-Termux)")
    elif sistema['windows']:
        print("‚úÖ Executando no Windows")
    elif sistema['macos']:
        print("‚úÖ Executando no macOS")
    elif sistema['linux']:
        print("‚úÖ Executando no Linux")
    else:
        print("‚ö†Ô∏è Sistema operacional n√£o identificado com precis√£o")
    return sistema

def instalar_dependencia_termux(pkg: str) -> None:
    """Verifica e instala um pacote do Termux, se necess√°rio."""
    try:
        subprocess.run(['pkg', 'update', '-y'], check=True, capture_output=True)
        resultado = subprocess.run(['pkg', 'list-installed', pkg], capture_output=True, text=True)
        if pkg in resultado.stdout:
            print(f"‚úÖ Pacote Termux {pkg} j√° est√° instalado")
            return
        print(f"‚ö†Ô∏è Instalando pacote Termux {pkg}...")
        subprocess.run(['pkg', 'install', '-y', pkg], check=True)
        print(f"‚úÖ Pacote Termux {pkg} instalado com sucesso!")
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Erro ao instalar pacote Termux {pkg}: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå Erro inesperado ao instalar {pkg}: {e}")
        sys.exit(1)

def instalar_dependencia_python(nome_pkg: str, pip_nome: str) -> None:
    """Verifica e instala uma depend√™ncia Python, se necess√°ria."""
    try:
        __import__(nome_pkg)
        print(f"‚úÖ M√≥dulo Python {nome_pkg} j√° est√° instalado")
    except ImportError:
        print(f"‚ö†Ô∏è Instalando m√≥dulo Python {nome_pkg}...")
        sistema = detectar_sistema()
        pip_cmd = [sys.executable, "-m", "pip", "install", pip_nome]
        if not sistema['termux']:
            pip_cmd.append("--user")
        try:
            subprocess.run(pip_cmd, check=True)
            print(f"‚úÖ M√≥dulo Python {nome_pkg} instalado com sucesso!")
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Erro ao instalar m√≥dulo Python {nome_pkg}: {e}")
            sys.exit(1)

def instalar_poppler() -> bool:
    """Instala o pacote poppler (pdftotext) de acordo com o sistema operacional."""
    sistema = detectar_sistema()
    print("‚ö†Ô∏è O pdftotext n√£o est√° instalado. Tentando instalar automaticamente...")
    try:
        if sistema['termux']:
            subprocess.run(['pkg', 'install', '-y', 'poppler'], check=True)
            print("‚úÖ poppler instalado com sucesso no Termux!")
            return True
        elif sistema['linux']:
            print("‚ö†Ô∏è Instalando poppler-utils no Linux...")
            subprocess.run(['sudo', 'apt-get', 'update'], check=True)
            subprocess.run(['sudo', 'apt-get', 'install', '-y', 'poppler-utils'], check=True)
            print("‚úÖ poppler-utils instalado com sucesso no Linux!")
            return True
        elif sistema['macos']:
            print("‚ö†Ô∏è Instalando poppler no macOS via Homebrew...")
            try:
                subprocess.run(['brew', '--version'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            except FileNotFoundError:
                print("‚ùå Homebrew n√£o est√° instalado no macOS. Instale-o e depois execute: brew install poppler")
                return False
            subprocess.run(['brew', 'install', 'poppler'], check=True)
            print("‚úÖ poppler instalado com sucesso no macOS!")
            return True
        elif sistema['windows']:
            print("‚ö†Ô∏è Instalando Poppler no Windows...")
            import tempfile, urllib.request, winreg
            poppler_url = "https://github.com/oschwartz10612/poppler-windows/releases/download/v23.11.0-0/Release-23.11.0-0.zip"
            try:
                temp_dir = tempfile.mkdtemp()
                zip_path = os.path.join(temp_dir, "poppler.zip")
                print("üì• Baixando Poppler...")
                urllib.request.urlretrieve(poppler_url, zip_path)
                program_files = os.environ.get('PROGRAMFILES', 'C:\\Program Files')
                poppler_dir = os.path.join(program_files, "Poppler")
                os.makedirs(poppler_dir, exist_ok=True)
                print("üì¶ Extraindo arquivos...")
                with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                    root_dirs = {item.split('/')[0] for item in zip_ref.namelist() if '/' in item}
                    if len(root_dirs) == 1:
                        root_dir = root_dirs.pop()
                        zip_ref.extractall(temp_dir)
                        extracted_dir = os.path.join(temp_dir, root_dir)
                        for item in os.listdir(extracted_dir):
                            src = os.path.join(extracted_dir, item)
                            dst = os.path.join(poppler_dir, item)
                            if os.path.exists(dst):
                                if os.path.isdir(dst):
                                    shutil.rmtree(dst)
                                else:
                                    os.remove(dst)
                            shutil.move(src, dst)
                    else:
                        zip_ref.extractall(poppler_dir)
                print("üîß Adicionando ao PATH do sistema...")
                bin_dir = os.path.join(poppler_dir, "bin")
                try:
                    key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, "Environment", 0, winreg.KEY_ALL_ACCESS)
                    try:
                        path, _ = winreg.QueryValueEx(key, "PATH")
                        if bin_dir.lower() not in path.lower():
                            new_path = path + ";" + bin_dir
                            winreg.SetValueEx(key, "PATH", 0, winreg.REG_EXPAND_SZ, new_path)
                            subprocess.run(["setx", "PATH", new_path], check=True, capture_output=True)
                    except FileNotFoundError:
                        winreg.SetValueEx(key, "PATH", 0, winreg.REG_EXPAND_SZ, bin_dir)
                    finally:
                        winreg.CloseKey(key)
                except Exception as e:
                    print(f"‚ö†Ô∏è Erro ao atualizar o PATH no Windows: {e}")
                os.environ["PATH"] = bin_dir + ";" + os.environ.get("PATH", "")
                shutil.rmtree(temp_dir, ignore_errors=True)
                print("‚úÖ Poppler instalado com sucesso no Windows!")
                print("‚ö†Ô∏è Voc√™ pode precisar reiniciar o terminal para que as altera√ß√µes no PATH tenham efeito.")
                try:
                    subprocess.run([os.path.join(bin_dir, "pdftotext"), "-v"], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
                    return True
                except (subprocess.CalledProcessError, FileNotFoundError):
                    print("‚ö†Ô∏è Poppler foi instalado, mas o pdftotext ainda n√£o est√° dispon√≠vel.")
                    return False
            except Exception as e:
                print(f"‚ùå Erro durante a instala√ß√£o autom√°tica do Poppler: {str(e)}")
                return False
        else:
            print("‚ùå Sistema operacional n√£o suportado para instala√ß√£o autom√°tica.")
            return False
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Erro ao instalar poppler: {e}")
        return False
    except Exception as e:
        print(f"‚ùå Erro inesperado ao instalar poppler: {e}")
        return False

def verificar_dependencias() -> None:
    """Verifica e instala as depend√™ncias necess√°rias para o sistema atual."""
    sistema = verificar_sistema()
    if sistema['termux']:
        pacotes_termux = ['python', 'python-pip', 'git', 'poppler', 'termux-api', 'ffmpeg']
        for pkg in pacotes_termux:
            instalar_dependencia_termux(pkg)
    dependencias_python = {
        'edge_tts': 'edge-tts>=6.1.5',
        'langdetect': 'langdetect>=1.0.9',
        'unidecode': 'unidecode>=1.3.6',
        'num2words': 'num2words>=0.5.12',
        'chardet': 'chardet>=5.0.0',
        'requests': 'requests>=2.31.0',
        'aioconsole': 'aioconsole>=0.6.0'
    }
    for nome_pkg, pip_nome in dependencias_python.items():
        instalar_dependencia_python(nome_pkg, pip_nome)
    try:
        subprocess.run(['pdftotext', '-v'], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        print("‚úÖ pdftotext (poppler) est√° funcionando corretamente")
    except FileNotFoundError:
        sistema = detectar_sistema()
        if sistema['windows']:
            print("üì¶ Poppler n√£o encontrado. Iniciando instala√ß√£o autom√°tica...")
            if not instalar_poppler_windows():
                print("‚ùå N√£o foi poss√≠vel instalar o pdftotext automaticamente.")
        elif sistema['macos']:
            print("‚ùå O pdftotext n√£o est√° instalado no sistema. Instale com: brew install poppler")
        elif sistema['termux']:
            print("‚ùå O pdftotext n√£o est√° instalado no sistema. Tente executar: pkg install poppler")
        else:
            print("‚ùå O pdftotext n√£o est√° instalado no sistema. Instale com: sudo apt-get install poppler-utils")
    
    # Verificar FFmpeg
    try:
        subprocess.run([FFMPEG_BIN, '-version'], stdout=subprocess.PIPE, stderr=subprocess.PIPE, check=True)
        print("‚úÖ FFmpeg est√° instalado e funcionando")
    except FileNotFoundError:
        print("‚ùå FFmpeg n√£o est√° instalado. √â necess√°rio para processamento de √°udio.")
        if sistema['termux']:
            print("Instale com: pkg install ffmpeg")
        elif sistema['linux']:
            print("Instale com: sudo apt-get install ffmpeg")
        elif sistema['macos']:
            print("Instale com: brew install ffmpeg")
        elif sistema['windows']:
            print("Baixe em: https://ffmpeg.org/download.html")

try:
    from num2words import num2words
    print("‚úÖ num2words importado com sucesso!")
except ImportError:
    print("\n‚ùå Erro ao importar num2words. Tente instalar manualmente: pip install --user num2words")
    sys.exit(1)

try:
    from langdetect import detect, DetectorFactory
    DetectorFactory.seed = 0
    LANG_DETECT_AVAILABLE = True
except ImportError:
    print("\n‚ö†Ô∏è O m√≥dulo langdetect n√£o est√° instalado. Para instalar, execute: pip install langdetect")
    LANG_DETECT_AVAILABLE = False

def limpar_tela() -> None:
    """Limpa a tela do terminal de forma compat√≠vel com todos os sistemas."""
    sistema = detectar_sistema()
    if sistema['windows']:
        os.system("cls")
    else:
        os.system("clear")

async def obter_opcao(prompt: str, opcoes: list) -> str:
    """Solicita ao usu√°rio uma entrada que esteja dentre as op√ß√µes v√°lidas."""
    while True:
        escolha = (await aioconsole.ainput(prompt)).strip()
        if escolha in opcoes:
            return escolha
        print("‚ö†Ô∏è Op√ß√£o inv√°lida! Tente novamente.")

def gravar_progresso(arquivo_progresso: str, indice: int) -> None:
    """Grava o √≠ndice da √∫ltima parte processada em arquivo."""
    with open(arquivo_progresso, 'w') as f:
        f.write(str(indice))

def ler_progresso(arquivo_progresso: str) -> int:
    """L√™ o √≠ndice da √∫ltima parte processada a partir do arquivo de progresso."""
    try:
        with open(arquivo_progresso, 'r') as f:
            return int(f.read().strip())
    except Exception:
        return 0

def limpar_nome_arquivo(nome: str) -> str:
    """Remove ou substitui caracteres inv√°lidos em sistemas de arquivos."""
    nome_limpo = re.sub(r'[<>:"/\\|?*]', '', nome)
    nome_limpo = nome_limpo.replace(' ', '_')
    return nome_limpo

async def menu_converter_mp3_para_mp4():
    await exibir_banner()
    print("\nüé¨ CONVERTER MP3 PARA MP4")

    dir_download = "/storage/emulated/0/Download"
    arquivos = listar_arquivos(dir_download, ['.mp3'])

    if not arquivos:
        print("\n‚ö†Ô∏è Nenhum arquivo MP3 encontrado na pasta Download.")
        await aioconsole.ainput("\nPressione ENTER para voltar ao menu...")
        return

    print("\nArquivos MP3 encontrados:")
    for i, nome in enumerate(arquivos, 1):
        print(f"{i}. {nome}")

    escolha = await obter_opcao("\nDigite o n√∫mero do arquivo MP3 para converter: ", [str(i) for i in range(1, len(arquivos) + 1)])
    arquivo_escolhido = arquivos[int(escolha) - 1]
    caminho_mp3 = os.path.join(dir_download, arquivo_escolhido)

    try:
        duracao = obter_duracao_ffprobe(caminho_mp3)
        saida_mp4 = os.path.splitext(caminho_mp3)[0] + ".mp4"
        criar_video_com_audio(caminho_mp3, saida_mp4, duracao)
        print(f"\n‚úÖ V√≠deo gerado com sucesso: {saida_mp4}")
    except Exception as e:
        print(f"\n‚ùå Erro ao gerar v√≠deo: {e}")

    await aioconsole.ainput("\nPressione ENTER para continuar...")

def unificar_audio(temp_files, arquivo_final) -> bool:
    """Une os arquivos de √°udio tempor√°rios em um √∫nico arquivo final."""
    try:
        if shutil.which(FFMPEG_BIN):
            list_file = os.path.join(os.path.dirname(arquivo_final), "file_list.txt")
            with open(list_file, "w") as f:
                for temp in temp_files:
                    f.write(f"file '{os.path.abspath(temp)}'\n")
            subprocess.run([FFMPEG_BIN, "-f", "concat", "-safe", "0", "-i", list_file, "-c", "copy", arquivo_final], check=True)
            os.remove(list_file)
        else:
            # Fallback: concatena√ß√£o bin√°ria (pode n√£o funcionar perfeitamente para mp3)
            with open(arquivo_final, "wb") as outfile:
                for temp in temp_files:
                    with open(temp, "rb") as infile:
                        outfile.write(infile.read())
        return True
    except Exception as e:
        print(f"‚ùå Erro na unifica√ß√£o dos arquivos: {e}")
        return False

async def atualizar_script() -> None:
    """Atualiza o script para a vers√£o mais recente do GitHub."""
    await exibir_banner()
    print("\nüîÑ ATUALIZA√á√ÉO DO SCRIPT")
    print("\nIsso ir√° baixar a vers√£o mais recente do script do GitHub.")
    confirmar = await obter_opcao("Deseja continuar? (s/n): ", ['s', 'n'])
    if confirmar != 's':
        print("\n‚ùå Atualiza√ß√£o cancelada pelo usu√°rio.")
        await aioconsole.ainput("\nPressione ENTER para continuar...")
        return
    print("\nüîÑ Baixando a vers√£o mais recente...")
    script_atual = os.path.abspath(__file__)
    script_backup = script_atual + ".backup"
    try:
        shutil.copy2(script_atual, script_backup)
        print(f"‚úÖ Backup criado: {script_backup}")
    except Exception as e:
        print(f"‚ö†Ô∏è N√£o foi poss√≠vel criar backup: {str(e)}")
        await aioconsole.ainput("\nPressione ENTER para continuar...")
        return
    sistema = detectar_sistema()
    url = "https://raw.githubusercontent.com/JonJonesBR/Conversor_TTS/main/Conversor_TTS_com_MP4_09.04.2025.py"
    try:
        if sistema['windows']:
            try:
                response = requests.get(url)
                if response.status_code == 200:
                    with open(script_atual, 'wb') as f:
                        f.write(response.content)
                    print("‚úÖ Script atualizado com sucesso!")
                else:
                    raise Exception(f"Erro ao baixar: c√≥digo {response.status_code}")
            except ImportError:
                resultado = subprocess.run(["curl", "-o", script_atual, url], capture_output=True, text=True)
                if resultado.returncode != 0:
                    raise Exception(f"Erro curl: {resultado.stderr}")
                print("‚úÖ Script atualizado com sucesso!")
        else:
            resultado = subprocess.run(["curl", "-o", script_atual, url], capture_output=True, text=True)
            if resultado.returncode != 0:
                raise Exception(f"Erro curl: {resultado.stderr}")
            print("‚úÖ Script atualizado com sucesso!")
        print("\nüîÑ O script ser√° reiniciado para aplicar as atualiza√ß√µes.")
        await aioconsole.ainput("Pressione ENTER para continuar...")
        python_exec = sys.executable
        os.execl(python_exec, python_exec, script_atual)
    except Exception as e:
        print(f"\n‚ùå Erro durante a atualiza√ß√£o: {str(e)}")
        print(f"\nüîÑ Restaurando backup...")
        try:
            shutil.copy2(script_backup, script_atual)
            print("‚úÖ Backup restaurado com sucesso!")
        except Exception as e2:
            print(f"‚ùå Erro ao restaurar backup: {str(e2)}")
            print(f"‚ö†Ô∏è O backup est√° dispon√≠vel em: {script_backup}")
        await aioconsole.ainput("\nPressione ENTER para continuar...")

async def exibir_banner() -> None:
    """Exibe o banner do programa."""
    limpar_tela()
    print("""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë         CONVERSOR TTS COMPLETO             ‚ïë
‚ïë Text-to-Speech + Melhoria de √Åudio em PT-BR‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
""")

async def menu_principal() -> str:
    """Exibe o menu principal e retorna a op√ß√£o escolhida."""
    await exibir_banner()
    print("\nEscolha uma op√ß√£o:")
    print("1. üöÄ CONVERTER TEXTO PARA √ÅUDIO")
    print("2. üéôÔ∏è TESTAR VOZES")
    print("3. ‚ö° MELHORAR √ÅUDIO EXISTENTE")
    print("4. ‚ùì AJUDA")
    print("5. üîÑ ATUALIZAR")
    print("6. üé¨ CONVERTER MP3 PARA MP4")
    print("7. üö™ SAIR")
    return await obter_opcao("\nOp√ß√£o: ", ['1', '2', '3', '4', '5', '6', '7'])

async def menu_vozes() -> str:
    """Exibe o menu de sele√ß√£o de vozes e retorna a voz escolhida."""
    await exibir_banner()
    print("\nVozes dispon√≠veis:")
    for i, voz in enumerate(VOZES_PT_BR, 1):
        print(f"{i}. {voz}")
    print(f"{len(VOZES_PT_BR) + 1}. Voltar")
    opcoes = [str(i) for i in range(1, len(VOZES_PT_BR) + 2)]
    escolha = await obter_opcao("\nEscolha uma voz: ", opcoes)
    if escolha == str(len(VOZES_PT_BR) + 1):
        return None
    return VOZES_PT_BR[int(escolha) - 1]

async def exibir_ajuda() -> None:
    """Exibe o guia de ajuda do programa."""
    await exibir_banner()
    print("""
üìñ GUIA DE USO:

1. CONVERS√ÉO DE TEXTO PARA √ÅUDIO:
   ‚Ä¢ Prepare seu arquivo de texto (.txt) ou PDF (.pdf)
   ‚Ä¢ Escolha uma voz e aguarde a convers√£o
   ‚Ä¢ O √°udio resultante pode ser melhorado na op√ß√£o 3

2. MELHORIA DE √ÅUDIO:
   ‚Ä¢ Acelere arquivos de √°udio/v√≠deo existentes
   ‚Ä¢ Escolha entre 0.5x e 2.0x de velocidade
   ‚Ä¢ Converta para MP3 (√°udio) ou MP4 (v√≠deo com tela preta)
   ‚Ä¢ Arquivos longos s√£o automaticamente divididos

6. CONVERTER MP3 PARA MP4:
   ‚Ä¢ Gere v√≠deos com tela preta a partir de arquivos de √°udio MP3
   ‚Ä¢ √ötil para publicar conte√∫dos de √°udio em plataformas como YouTube

‚ö†Ô∏è OBSERVA√á√ïES:
‚Ä¢ Para arquivos muito grandes, o processo pode demorar
‚Ä¢ Certifique-se de ter espa√ßo em disco suficiente
‚Ä¢ No Android/Termux, os arquivos s√£o salvos em /storage/emulated/0/Download
""")
    await aioconsole.ainput("\nPressione ENTER para voltar ao menu principal...")

async def testar_voz(voz: str) -> None:
    """
    Testa uma voz espec√≠fica com um texto de exemplo e salva a amostra
    em uma pasta na pasta Download do Android. Ap√≥s a gera√ß√£o, retorna automaticamente.
    """
    texto_teste = "Ol√°! Esta √© uma demonstra√ß√£o da minha voz."
    communicate = edge_tts.Communicate(texto_teste, voz)
    sistema = detectar_sistema()
    if sistema['android'] or sistema['termux']:
        download_folder = "/storage/emulated/0/Download"
        test_folder = os.path.join(download_folder, "TTS_Teste_Voz")
        os.makedirs(test_folder, exist_ok=True)
        file_path = os.path.join(test_folder, f"teste_voz_{voz}.mp3")
    else:
        file_path = "teste_voz.mp3"
    try:
        await communicate.save(file_path)
        print(f"\n‚úÖ Arquivo de teste gerado: {file_path}")
        if sistema['termux']:
            if shutil.which("termux-media-player"):
                try:
                    subprocess.run(['termux-media-player', 'play', file_path], timeout=10)
                except subprocess.TimeoutExpired:
                    print("Aviso: reprodu√ß√£o de √°udio demorou, continuando...")
            else:
                print("termux-media-player n√£o dispon√≠vel, √°udio n√£o reproduzido.")
        elif sistema['windows']:
            os.startfile(file_path)
        else:
            subprocess.Popen(['xdg-open', file_path])
        await asyncio.sleep(1)
    except Exception as e:
        print(f"\n‚ùå Erro ao testar voz: {str(e)}")

def listar_arquivos(diretorio: str, extensoes: list = None) -> list:
    """Lista arquivos no diret√≥rio especificado, filtrando por extens√µes se fornecido."""
    arquivos = []
    try:
        for item in os.listdir(diretorio):
            caminho_completo = os.path.join(diretorio, item)
            if os.path.isfile(caminho_completo):
                if not extensoes or os.path.splitext(item)[1].lower() in extensoes:
                    arquivos.append(item)
    except Exception as e:
        print(f"\n‚ö†Ô∏è Erro ao listar arquivos: {str(e)}")
    return sorted(arquivos)

# ================== FUN√á√ïES DE CORRE√á√ÉO DE TEXTO ==================

def normalizar_texto_corrigir(texto):
    """Normaliza o texto preservando acentos."""
    print("\n[1/5] Normalizando texto...")
    return unicodedata.normalize('NFKC', texto)

def corrigir_espacamento_corrigir(texto):
    """Corrige espa√ßamentos desnecess√°rios e remove espa√ßos no in√≠cio e fim das linhas."""
    print("[2/5] Corrigindo espa√ßamento...")
    texto = re.sub(r'\s+', ' ', texto)
    texto = re.sub(r'^\s+|\s+$', '', texto, flags=re.MULTILINE)
    return texto

def ajustar_titulo_e_capitulos_corrigir(texto):
    """
    Ajusta t√≠tulo, autor e formata cap√≠tulos.
    Tenta separar o cabe√ßalho (t√≠tulo e autor) se estiver em uma √∫nica linha.
    """
    print("[3/5] Ajustando t√≠tulo, autor e cap√≠tulos...")
    pattern = r"^(?P<titulo>.+?)\s+(?P<autor>[A-Z][a-z]+(?:\s+[A-Z][a-z]+))\s+(?P<body>.*)$"
    match = re.match(pattern, texto, re.DOTALL)
    if match:
        titulo = match.group("titulo").strip()
        autor = match.group("autor").strip()
        body = match.group("body").strip()
        if not titulo.endswith(('.', '!', '?')):
            titulo += '.'
        if not autor.endswith(('.', '!', '?')):
            autor += '.'
        novo_texto = titulo + "\n" + autor + "\n\n" + body
    else:
        linhas = texto.splitlines()
        header = []
        corpo = []
        non_empty_count = 0
        for linha in linhas:
            if linha.strip():
                non_empty_count += 1
                if non_empty_count <= 2:
                    header.append(linha.strip())
                else:
                    corpo.append(linha)
            else:
                if non_empty_count >= 2:
                    corpo.append(linha)
        if len(header) == 1:
            palavras = header[0].split()
            if len(palavras) >= 4 and palavras[-1][0].isupper() and palavras[-2][0].isupper():
                autor = " ".join(palavras[-2:])
                titulo = " ".join(palavras[:-2])
                header = [titulo.strip(), autor.strip()]
        if header:
            if not header[0].endswith(('.', '!', '?')):
                header[0] += '.'
        if len(header) > 1:
            if not header[1].endswith(('.', '!', '?')):
                header[1] += '.'
        novo_texto = "\n".join(header + [""] + corpo)
    novo_texto = re.sub(r'(?i)\b(cap√≠tulo\s*\d+)\b', r'\n\n\1.\n\n', novo_texto)
    return novo_texto

def inserir_quebra_apos_ponto_corrigir(texto):
    """Insere uma quebra de par√°grafo ap√≥s cada ponto final."""
    print("[4/5] Inserindo quebra de par√°grafo ap√≥s cada ponto final...")
    
    # Primeiro normaliza espa√ßos em branco e quebras existentes
    texto = re.sub(r'\s+', ' ', texto)  # Substitui m√∫ltiplos espa√ßos por um √∫nico
    texto = re.sub(r'(?<!\n)\n(?!\n)', ' ', texto)  # Remove quebras de linha isoladas
    
    # Insere quebras de par√°grafo apenas ap√≥s pontos finais
    texto = re.sub(r'\.\s+', '.\n\n', texto)
    
    # Remove poss√≠veis m√∫ltiplas quebras criadas
    texto = re.sub(r'\n{3,}', '\n\n', texto)
    
    # Garante que n√£o haja espa√ßos antes de quebras
    texto = re.sub(r' +\n', '\n', texto)
    
    return texto

def formatar_paragrafos_corrigir(texto):
    """Formata os par√°grafos garantindo uma linha em branco entre eles."""
    print("[5/5] Formatando par√°grafos...")
    paragrafos = [p.strip() for p in texto.split('\n\n') if p.strip()]
    return '\n\n'.join(paragrafos)

def expandir_abreviacoes(texto):
    abreviacoes = {
    r'\bDr\.(?=\s)': 'Doutor',
    r'\bD\.(?=\s)': 'Dona',
    r'\bDra\.(?=\s)': 'Doutora',
    r'\bSr\.(?=\s)': 'Senhor',
    r'\bSra\.(?=\s)': 'Senhora',
    r'\bSrta\.(?=\s)': 'Senhorita',
    r'\bProf\.(?=\s)': 'Professor',
    r'\bProfa\.(?=\s)': 'Professora',
    r'\bEng\.(?=\s)': 'Engenheiro',
    r'\bEng¬™\.(?=\s)': 'Engenheira',
    r'\bAdm\.(?=\s)': 'Administrador',
    r'\bAdv\.(?=\s)': 'Advogado',
    r'\bExmo\.(?=\s)': 'Excelent√≠ssimo',
    r'\bExma\.(?=\s)': 'Excelent√≠ssima',
    r'\bV\.Exa\.(?=\s)': 'Vossa Excel√™ncia',
    r'\bV\.Sa\.(?=\s)': 'Vossa Senhoria',
    r'\bAv\.(?=\s)': 'Avenida',
    r'\bR\.(?=\s)': 'Rua',
    r'\bKm\.(?=\s)': 'Quil√¥metro',
    r'\betc\.(?=\s)': 'etc√©tera',
    r'\bRef\.(?=\s)': 'Refer√™ncia',
    r'\bPag\.(?=\s)': 'P√°gina',
    r'\bP√°g\.(?=\s)': 'P√°gina',
    r'\bP√°gs\.(?=\s)': 'P√°ginas',
    r'\bPags\.(?=\s)': 'P√°ginas',
    r'\bFl\.(?=\s)': 'Folha',
    r'\bPe\.(?=\s)': 'Padre',
    r'\bFls\.(?=\s)': 'Folhas',
    r'\bDept\.(?=\s)': 'Departamento',
    r'\bDepto\.(?=\s)': 'Departamento',
    r'\bUniv\.(?=\s)': 'Universidade',
    r'\bInst\.(?=\s)': 'Institui√ß√£o',
    r'\bEst\.(?=\s)': 'Estado',
    r'\bTel\.(?=\s)': 'Telefone',
    r'\bCEP\.(?=\s)': 'C√≥digo de Endere√ßamento Postal',
    r'\bCNPJ\.(?=\s)': 'Cadastro Nacional da Pessoa Jur√≠dica',
    r'\bCPF\.(?=\s)': 'Cadastro de Pessoas F√≠sicas',
    r'\bEUA\.(?=\s)': 'Estados Unidos da Am√©rica',
    r'\bEd\.(?=\s)': 'Edi√ß√£o',
    r'\bLtda\.(?=\s)': 'Limitada'
}
    for abrev, extensao in abreviacoes.items():
        texto = re.sub(abrev, extensao, texto)
    return texto

def melhorar_texto_corrigido(texto):
    texto = texto.replace('\f', '\n\n')  # Remove form feeds
    texto = remover_numeracao_avulsa(texto)
    
    # Remover quebras de linha excessivas (exceto ap√≥s pontos finais)
    texto = re.sub(r'(?<!\n)\n(?!\n|\.\s*)', ' ', texto)  # Remove quebras de linha √∫nicas
    texto = re.sub(r'\n{3,}', '\n\n', texto)  # Limita m√∫ltiplas quebras para no m√°ximo duas
    
    # Garantir quebras de linha apenas ap√≥s pontos finais
    texto = re.sub(r'\.\s+', '.\n\n', texto)
    
    # Fun√ß√µes auxiliares mantidas conforme original
    def remover_num_paginas_rodapes(texto):
        return re.sub(r'\n?\s*\d+\s+cda_pr_.*?\.indd\s+\d+\s+\d+/\d+/\d+\s+\d+:\d+\s+[APM]{2}', '', texto)

    def corrigir_hifenizacao(texto):
        return re.sub(r'(\w+)-\s*\n\s*(\w+)', r'\1\2', texto)

    def remover_infos_bibliograficas_rodape(texto):
        return re.sub(r'^\s*(cda_pr_.*?\.indd.*?)$', '', texto, flags=re.MULTILINE)

    def converter_capitulos_para_extenso_simples(texto):
        substituicoes = {
            'CAP√çTULO I': 'CAP√çTULO UM',
            'CAP√çTULO II': 'CAP√çTULO DOIS',
            'CAP√çTULO III': 'CAP√çTULO TR√äS',
            'CAP√çTULO IV': 'CAP√çTULO QUATRO',
            'CAP√çTULO V': 'CAP√çTULO CINCO',
            'CAP√çTULO VI': 'CAP√çTULO SEIS',
            'CAP√çTULO VII': 'CAP√çTULO SETE',
            'CAP√çTULO VIII': 'CAP√çTULO OITO',
            'CAP√çTULO IX': 'CAP√çTULO NOVE',
            'CAP√çTULO X': 'CAP√çTULO DEZ',
        }
        for original, novo in substituicoes.items():
            texto = texto.replace(original, novo)
        return texto

    # Aplicar as fun√ß√µes auxiliares
    texto = remover_num_paginas_rodapes(texto)
    texto = corrigir_hifenizacao(texto)
    texto = remover_infos_bibliograficas_rodape(texto)
    texto = converter_capitulos_para_extenso_simples(texto)
    
    # Garantir que cada par√°grafo termine com pontua√ß√£o
    paragrafos = texto.split('\n\n')
    paragrafos_corrigidos = []
    for p in paragrafos:
        p = p.strip()
        if p and not re.search(r'[.!?‚Ä¶]$', p):
            p += '.'
        paragrafos_corrigidos.append(p)
    texto = '\n\n'.join(paragrafos_corrigidos)
    
    return texto

    def pontuar_finais_de_paragrafo(texto):
        paragrafos = texto.split('\n\n')
        paragrafos_corrigidos = []
        for p in paragrafos:
            p = p.strip()
            if p and not re.search(r'[.!?‚Ä¶]$', p):
                p += '.'
            paragrafos_corrigidos.append(p)
        return '\n\n'.join(paragrafos_corrigidos)

    texto = remover_num_paginas_rodapes(texto)
    texto = corrigir_hifenizacao(texto)
    texto = remover_infos_bibliograficas_rodape(texto)
    texto = converter_capitulos_para_extenso_simples(texto)
    texto = pontuar_finais_de_paragrafo(texto)
    texto = expandir_abreviacoes(texto)
    return texto


def verificar_e_corrigir_arquivo(caminho_txt: str) -> str:
    """
    Verifica se o arquivo TXT j√° foi processado (cont√©m o sufixo '_formatado').
    Caso n√£o, l√™ o arquivo, o processa e o salva com o sufixo, retornando o novo caminho.
    """
    base, ext = os.path.splitext(caminho_txt)
    if base.endswith("_formatado"):
        return caminho_txt
    try:
        with open(caminho_txt, 'r', encoding='utf-8') as f:
            conteudo = f.read()
    except Exception as e:
        print(f"‚ùå Erro ao ler o arquivo TXT: {e}")
        return caminho_txt
    conteudo_corrigido = melhorar_texto_corrigido(conteudo)
    novo_caminho = base + "_formatado" + ext
    try:
        with open(novo_caminho, 'w', encoding='utf-8') as f:
            f.write(conteudo_corrigido)
        print(f"‚úÖ Arquivo corrigido e salvo em: {novo_caminho}")
    except Exception as e:
        print(f"‚ùå Erro ao salvar o arquivo corrigido: {e}")
        return caminho_txt
    return novo_caminho

# ================== FUN√á√ïES DE MELHORIA DE √ÅUDIO ==================

def obter_duracao_ffprobe(caminho_arquivo):
    """Obt√©m a dura√ß√£o de um arquivo de m√≠dia usando ffprobe."""
    comando = [
        FFPROBE_BIN,
        '-v', 'error',
        '-show_entries', 'format=duration',
        '-of', 'default=noprint_wrappers=1:nokey=1',
        caminho_arquivo
    ]
    resultado = subprocess.run(comando, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
    return float(resultado.stdout.strip())

def acelerar_audio(input_path, output_path, velocidade):
    """Acelera um arquivo de √°udio usando o filtro atempo do FFmpeg."""
    comando = [
        FFMPEG_BIN,
        '-y',
        '-i', input_path,
        '-filter:a', f"atempo={velocidade}",
        '-vn',
        output_path
    ]
    subprocess.run(comando, check=True)

def criar_video_com_audio(audio_path, video_path, duracao):
    """Cria um v√≠deo com tela preta a partir de um arquivo de √°udio."""
    comando = [
        FFMPEG_BIN,
        '-y',
        '-f', 'lavfi',
        '-i', f"color=c=black:s=1280x720:d={int(duracao)}",
        '-i', audio_path,
        '-shortest',
        '-c:v', 'libx264',
        '-c:a', 'aac',
        '-b:a', '192k',
        '-pix_fmt', 'yuv420p',
        video_path
    ]
    subprocess.run(comando, check=True)

def dividir_em_partes(input_path, duracao_total, duracao_maxima, nome_base_saida, extensao):
    """Divide um arquivo de m√≠dia em partes menores."""
    partes = ceil(duracao_total / duracao_maxima)
    for i in range(partes):
        inicio = i * duracao_maxima
        duracao = min(duracao_maxima, duracao_total - inicio)

        output_path = f"{nome_base_saida}_parte{i+1}{extensao}"

        comando = [
            FFMPEG_BIN,
            '-y',
            '-i', input_path,
            '-ss', str(int(inicio)),
            '-t', str(int(duracao)),
            '-c', 'copy',
            output_path
        ]
        subprocess.run(comando, check=True)
        print(f"    Parte {i+1} criada: {output_path}")

async def menu_melhorar_audio():
    """Menu para melhorar arquivos de √°udio/v√≠deo existentes."""
    await exibir_banner()
    print("\n‚ö° MELHORAR √ÅUDIO EXISTENTE")
    
    sistema = detectar_sistema()
    if sistema['termux'] or sistema['android']:
        dir_atual = '/storage/emulated/0/Download'
    elif sistema['windows']:
        dir_atual = os.path.join(os.path.expanduser('~'), 'Desktop')
    else:
        dir_atual = os.path.join(os.path.expanduser('~'), 'Desktop')
    
    while True:
        print(f"\nDiret√≥rio atual: {dir_atual}")
        print("\nArquivos de √°udio/v√≠deo dispon√≠veis:")
        arquivos = listar_arquivos(dir_atual, ['.mp3', '.wav', '.m4a', '.mp4'])
        
        if not arquivos:
            print("\n‚ö†Ô∏è Nenhum arquivo de √°udio/v√≠deo encontrado neste diret√≥rio")
        else:
            for i, arquivo in enumerate(arquivos, 1):
                print(f"{i}. {arquivo}")
        
        print("\nOp√ß√µes:")
        print("D. Mudar diret√≥rio")
        print("M. Digitar caminho manualmente")
        print("V. Voltar ao menu principal")
        
        escolha = (await aioconsole.ainput("\nEscolha uma op√ß√£o: ")).strip().upper()
        
        if escolha == 'V':
            return
        elif escolha == 'D':
            novo_dir = (await aioconsole.ainput("\nDigite o caminho do novo diret√≥rio: ")).strip()
            if os.path.isdir(novo_dir):
                dir_atual = novo_dir
            else:
                print("\n‚ùå Diret√≥rio inv√°lido")
                await asyncio.sleep(1)
        elif escolha == 'M':
            caminho = (await aioconsole.ainput("\nDigite o caminho completo do arquivo: ")).strip()
            if not os.path.exists(caminho):
                print(f"\n‚ùå Arquivo n√£o encontrado: {caminho}")
                await asyncio.sleep(1)
                continue
            ext = os.path.splitext(caminho)[1].lower()
            if ext not in ['.mp3', '.wav', '.m4a', '.mp4']:
                print("\n‚ùå Formato n√£o suportado. Use MP3, WAV, M4A ou MP4.")
                await asyncio.sleep(1)
                continue
            await processar_melhorar_audio(caminho)
            return
        elif escolha.isdigit():
            indice = int(escolha) - 1
            if 0 <= indice < len(arquivos):
                arquivo_selecionado = arquivos[indice]
                caminho_completo = os.path.join(dir_atual, arquivo_selecionado)
                await processar_melhorar_audio(caminho_completo)
                return
            else:
                print("\n‚ùå Op√ß√£o inv√°lida")
                await asyncio.sleep(1)
        else:
            print("\n‚ùå Op√ß√£o inv√°lida")
            await asyncio.sleep(1)

from pathlib import Path

async def processar_melhorar_audio(arquivo):
    """Processa a melhoria de um arquivo de √°udio/v√≠deo."""
    global CANCELAR_PROCESSAMENTO
    CANCELAR_PROCESSAMENTO = False
    
    try:
        nome_base, ext = os.path.splitext(arquivo)
        ext = ext.lower()

        if ext not in ['.mp3', '.wav', '.m4a', '.mp4']:
            print(f"\n‚ùå Formato n√£o suportado: {ext}")
            await asyncio.sleep(1)
            return

        # Configura√ß√µes de velocidade
        while True:
            try:
                velocidade = float((await aioconsole.ainput("\nInforme a velocidade de reprodu√ß√£o desejada (ex: 1.25, 1.5, 2.0): ")).strip())
                if not (0.5 <= velocidade <= 2.0):
                    raise ValueError
                break
            except ValueError:
                print("Valor inv√°lido. Digite um n√∫mero entre 0.5 e 2.0.")

        # Formato de sa√≠da
        while True:
            formato = (await aioconsole.ainput("\nEscolha o formato de sa√≠da [mp3 para √°udio | mp4 para v√≠deo]: ")).strip().lower()
            if formato in ["mp3", "mp4"]:
                break
            else:
                print("Formato inv√°lido. Digite 'mp3' ou 'mp4'.")

        # Normaliza nome de sa√≠da
        nome_saida_base = f"{nome_base}_x{velocidade}".replace(".", "_")
        nome_saida_base = re.sub(r'_+', '_', nome_saida_base)  # Remove underlines duplos

        # Cria diret√≥rio de sa√≠da, se necess√°rio
        Path(os.path.dirname(nome_saida_base)).mkdir(parents=True, exist_ok=True)

        temp_audio = f"{nome_saida_base}_temp_audio.mp3"

        print(f"\n[+] Processando: {arquivo}")
        print(f"    Aumentando velocidade ({velocidade}x)...")

        acelerar_audio(arquivo, temp_audio, velocidade)
        duracao = obter_duracao_ffprobe(temp_audio)
        print(f"    Dura√ß√£o ap√≥s acelera√ß√£o: {duracao / 3600:.2f} horas")

        extensao_final = ".mp4" if formato == "mp4" else ".mp3"

        if duracao <= LIMITE_SEGUNDOS:
            saida_final = f"{nome_saida_base}{extensao_final}"
            if formato == "mp4":
                print("    Gerando v√≠deo com tela preta...")
                criar_video_com_audio(temp_audio, saida_final, duracao)
                os.remove(temp_audio)
            else:
                os.rename(temp_audio, saida_final)
            print(f"    Arquivo final salvo: {saida_final}")
        else:
            print("    Dividindo em partes de at√© 12 horas...")
            if formato == "mp4":
                video_completo = f"{nome_saida_base}_video.mp4"
                criar_video_com_audio(temp_audio, video_completo, duracao)
                dividir_em_partes(video_completo, duracao, LIMITE_SEGUNDOS, nome_saida_base, ".mp4")
                os.remove(video_completo)
            else:
                dividir_em_partes(temp_audio, duracao, LIMITE_SEGUNDOS, nome_saida_base, ".mp3")
            os.remove(temp_audio)
            print("    Arquivos divididos com sucesso.")

        await aioconsole.ainput("\nPressione ENTER para continuar...")

    except Exception as e:
        print(f"\n‚ùå Erro ao processar arquivo: {str(e)}")
        await aioconsole.ainput("\nPressione ENTER para continuar...")
    finally:
        CANCELAR_PROCESSAMENTO = True


def extrair_texto_de_epub(caminho_arquivo: str) -> str:
    """
    Extrai o conte√∫do textual de um arquivo EPUB, converte para texto plano,
    aplica formata√ß√£o e retorna o caminho do arquivo TXT final.
    """
    try:
        print(f"\nüìñ Extraindo conte√∫do de: {caminho_arquivo}")
        texto_extraido = ""
        with zipfile.ZipFile(caminho_arquivo, 'r') as epub:
            arquivos_html = [
                f for f in epub.namelist()
                if f.endswith(('.html', '.xhtml')) and not re.search(r'(toc|nav|cover)', f, re.IGNORECASE)
            ]
            arquivos_html.sort()

            for nome_arquivo in arquivos_html:
                with epub.open(nome_arquivo) as f:
                    html_bytes = f.read()
                    encoding_detectado = chardet.detect(html_bytes)['encoding'] or 'utf-8'
                    try:
                        html_texto = html_bytes.decode(encoding_detectado, errors='ignore')
                    except Exception as e:
                        print(f"‚ùå Erro ao decodificar {nome_arquivo}: {e}")
                        continue

                    soup = BeautifulSoup(html_texto, 'html.parser')
                    for tag in soup(['nav', 'header', 'footer', 'style', 'script']):
                        tag.decompose()

                    corpo = soup.get_text(separator=' ', strip=True)
                    if corpo:
                        texto_convertido = html2text.html2text(corpo)
                        texto_extraido += texto_convertido + "\n\n"

        if not texto_extraido.strip():
            print("‚ö†Ô∏è Nenhum conte√∫do textual extra√≠do do EPUB.")
            return ""

        nome_base = os.path.splitext(caminho_arquivo)[0]
        caminho_txt_extraido = nome_base + "_extraido.txt"
        with open(caminho_txt_extraido, 'w', encoding='utf-8') as f:
            f.write(texto_extraido)

        caminho_corrigido = verificar_e_corrigir_arquivo(caminho_txt_extraido)
        texto_formatado = aplicar_formatacao(ler_arquivo_texto(caminho_corrigido))
        caminho_formatado = nome_base + "_formatado.txt"
        with open(caminho_formatado, 'w', encoding='utf-8') as f:
            f.write(texto_formatado)

        return caminho_formatado  # retorno do extrair_texto_de_epub
    except Exception as e:
        print(f"‚ùå Erro ao extrair texto do EPUB: {e}")
        return ""

# ================== FUN√á√ïES DE LEITURA E PROCESSAMENTO DE ARQUIVOS ==================

def detectar_encoding(caminho_arquivo: str) -> str:
    """Detecta o encoding de um arquivo de texto."""
    try:
        with open(caminho_arquivo, 'rb') as f:
            resultado = chardet.detect(f.read())
        encoding_detectado = resultado['encoding']
        if not encoding_detectado:
            for enc in ENCODINGS_TENTATIVAS:
                try:
                    with open(caminho_arquivo, 'r', encoding=enc) as f:
                        f.read(100)
                    return enc
                except UnicodeDecodeError:
                    continue
            return 'utf-8'
        return encoding_detectado
    except Exception as e:
        print(f"\n‚ö†Ô∏è Erro ao detectar encoding: {str(e)}")
        return 'utf-8'

def ler_arquivo_texto(caminho_arquivo: str) -> str:
    """L√™ o conte√∫do de um arquivo de texto com detec√ß√£o autom√°tica de encoding."""
    encoding = detectar_encoding(caminho_arquivo)
    try:
        with open(caminho_arquivo, 'r', encoding=encoding) as f:
            conteudo = f.read()
        return conteudo
    except Exception as e:
        print(f"\n‚ùå Erro ao ler arquivo: {str(e)}")
        return ""

def processar_texto(texto: str) -> str:
    """Processa o texto para melhorar a qualidade da convers√£o TTS."""
    # Remover caracteres n√£o imprim√≠veis
    texto = re.sub(r'[\x00-\x1F\x7F-\x9F]', '', texto)
    texto = texto.encode('utf-8', 'ignore').decode('utf-8')

    texto = re.sub(r'\s+', ' ', texto)
    abreviacoes = {
    r'\bDr\.(?=\s)': 'Doutor',
    r'\bD\.(?=\s)': 'Dona',
    r'\bDra\.(?=\s)': 'Doutora',
    r'\bSr\.(?=\s)': 'Senhor',
    r'\bSra\.(?=\s)': 'Senhora',
    r'\bSrta\.(?=\s)': 'Senhorita',
    r'\bProf\.(?=\s)': 'Professor',
    r'\bProfa\.(?=\s)': 'Professora',
    r'\bEng\.(?=\s)': 'Engenheiro',
    r'\bEng¬™\.(?=\s)': 'Engenheira',
    r'\bAdm\.(?=\s)': 'Administrador',
    r'\bAdv\.(?=\s)': 'Advogado',
    r'\bExmo\.(?=\s)': 'Excelent√≠ssimo',
    r'\bExma\.(?=\s)': 'Excelent√≠ssima',
    r'\bV\.Exa\.(?=\s)': 'Vossa Excel√™ncia',
    r'\bV\.Sa\.(?=\s)': 'Vossa Senhoria',
    r'\bAv\.(?=\s)': 'Avenida',
    r'\bR\.(?=\s)': 'Rua',
    r'\bKm\.(?=\s)': 'Quil√¥metro',
    r'\betc\.(?=\s)': 'etc√©tera',
    r'\bRef\.(?=\s)': 'Refer√™ncia',
    r'\bPag\.(?=\s)': 'P√°gina',
    r'\bP√°g\.(?=\s)': 'P√°gina',
    r'\bP√°gs\.(?=\s)': 'P√°ginas',
    r'\bPags\.(?=\s)': 'P√°ginas',
    r'\bFl\.(?=\s)': 'Folha',
    r'\bPe\.(?=\s)': 'Padre',
    r'\bFls\.(?=\s)': 'Folhas',
    r'\bDept\.(?=\s)': 'Departamento',
    r'\bDepto\.(?=\s)': 'Departamento',
    r'\bUniv\.(?=\s)': 'Universidade',
    r'\bInst\.(?=\s)': 'Institui√ß√£o',
    r'\bEst\.(?=\s)': 'Estado',
    r'\bTel\.(?=\s)': 'Telefone',
    r'\bCEP\.(?=\s)': 'C√≥digo de Endere√ßamento Postal',
    r'\bCNPJ\.(?=\s)': 'Cadastro Nacional da Pessoa Jur√≠dica',
    r'\bCPF\.(?=\s)': 'Cadastro de Pessoas F√≠sicas',
    r'\bEUA\.(?=\s)': 'Estados Unidos da Am√©rica',
    r'\bEd\.(?=\s)': 'Edi√ß√£o',
    r'\bLtda\.(?=\s)': 'Limitada'
}

    for abrev, expansao in abreviacoes.items():
        texto = re.sub(abrev, expansao, texto)

    def converter_numero(match):
        num = match.group(0)
        try:
            return num2words(int(num), lang='pt_BR')
        except:
            return num

    def converter_valor_monetario(match):
        valor = match.group(1)
        try:
            return f"{num2words(int(valor), lang='pt_BR')} reais"
        except:
            return f"{valor} reais"

    texto = re.sub(r'\b\d+\b', converter_numero, texto)
    texto = re.sub(r'R\$\s*(\d+)', converter_valor_monetario, texto)
    texto = re.sub(r'\b(\d+)\s*-\s*(\d+)\b', lambda m: f"{num2words(int(m.group(1)), lang='pt_BR')} a {num2words(int(m.group(2)), lang='pt_BR')}", texto)

    return texto

def dividir_texto(texto: str) -> list:
    """
    Divide o texto em partes menores para processamento, respeitando os pontos finais.
    """
    partes = []
    start = 0
    while start < len(texto):
        next_period = texto.find('.', start)
        if next_period == -1:
            partes.append(texto[start:].strip())
            break
        end = next_period + 1
        partes.append(texto[start:end].strip())
        start = end
    return [p for p in partes if p]

async def converter_texto_para_audio(texto: str, voz: str, caminho_saida: str) -> bool:
    """Converte texto para √°udio usando Edge TTS."""
    tentativas = 0
    while tentativas < MAX_TENTATIVAS:
        try:
            if not texto.strip():
                print("‚ö†Ô∏è Texto vazio detectado")
                return False
                
            communicate = edge_tts.Communicate(texto, voz)
            await communicate.save(caminho_saida)
            
            # Verifica se o arquivo foi criado e tem tamanho m√≠nimo
            if os.path.exists(caminho_saida) and os.path.getsize(caminho_saida) > 1024:
                return True
            else:
                print("‚ö†Ô∏è Arquivo de √°udio vazio ou muito pequeno")
                if os.path.exists(caminho_saida):
                    os.remove(caminho_saida)
                return False
        except Exception as e:
            tentativas += 1
            print(f"\n‚ùå Erro na convers√£o (tentativa {tentativas}/{MAX_TENTATIVAS}): {str(e)}")
            if os.path.exists(caminho_saida):
                os.remove(caminho_saida)
            if tentativas < MAX_TENTATIVAS:
                await asyncio.sleep(2)  # Espera antes de tentar novamente
    return False

# ================== FUN√á√ïES DE SELE√á√ÉO E CONVERS√ÉO DE ARQUIVOS ==================

async def selecionar_arquivo() -> str:
    """
    Interface aprimorada para sele√ß√£o de arquivo com navega√ß√£o por diret√≥rios.
    Se o usu√°rio selecionar um PDF, ele √© convertido para TXT e o arquivo gerado √© corrigido.
    Se for um arquivo TXT e o nome n√£o contiver '_formatado', o arquivo √© automaticamente corrigido.
    """
    sistema = detectar_sistema()
    if sistema['termux'] or sistema['android']:
        dir_atual = '/storage/emulated/0/Download'
    elif sistema['windows']:
        dir_atual = os.path.join(os.path.expanduser('~'), 'Desktop')
    else:
        dir_atual = os.path.join(os.path.expanduser('~'), 'Desktop')
    while True:
        await exibir_banner()
        print("\nüìÇ SELE√á√ÉO DE ARQUIVO")
        print(f"\nDiret√≥rio atual: {dir_atual}")
        print("\nArquivos dispon√≠veis:")
        arquivos = listar_arquivos(dir_atual, ['.txt', '.pdf', '.epub'])
        if not arquivos:
            print("\n‚ö†Ô∏è Nenhum arquivo TXT ou PDF encontrado neste diret√≥rio")
        else:
            for i, arquivo in enumerate(arquivos, 1):
                print(f"{i}. {arquivo}")
        print("\nOp√ß√µes:")
        print("D. Mudar diret√≥rio")
        print("M. Digitar caminho manualmente")
        print("V. Voltar ao menu principal")
        try:
            escolha = (await aioconsole.ainput("\nEscolha uma op√ß√£o: ")).strip().upper()
        except asyncio.TimeoutError:
            return ''
        
        if escolha == 'V':
            return ''
        elif escolha == 'D':
            novo_dir = (await aioconsole.ainput("\nDigite o caminho do novo diret√≥rio: ")).strip()
            if os.path.isdir(novo_dir):
                dir_atual = novo_dir
            else:
                print("\n‚ùå Diret√≥rio inv√°lido")
                await asyncio.sleep(1)
        elif escolha == 'M':
            caminho = (await aioconsole.ainput("\nDigite o caminho completo do arquivo: ")).strip()
            if not os.path.exists(caminho):
                print(f"\n‚ùå Arquivo n√£o encontrado: {caminho}")
                await asyncio.sleep(1)
                continue
            ext = os.path.splitext(caminho)[1].lower()
            if ext == '.pdf':
                caminho_txt = os.path.splitext(caminho)[0] + '.txt'
                if not converter_pdf(caminho, caminho_txt):
                    print("\n‚ö†Ô∏è Falha na convers√£o do PDF. Tente outro arquivo.")
                    await asyncio.sleep(1)
                    continue
                # Ap√≥s converter, verifica se o TXT j√° foi corrigido
                try:
                    with open(caminho_txt, 'r', encoding='utf-8') as f:
                        texto_original = f.read()
                    texto_formatado = aplicar_formatacao(texto_original)
                    caminho_txt = os.path.splitext(caminho_txt)[0] + '_formatado.txt'
                    with open(caminho_txt, 'w', encoding='utf-8') as f:
                        f.write(texto_formatado)
                    print(f'‚úÖ Formata√ß√£o aplicada e salva em: {caminho_txt}')
                except Exception as e:
                    print(f'‚ùå Erro ao aplicar formata√ß√£o: {e}')
                caminho_txt = verificar_e_corrigir_arquivo(caminho_txt)
                editar = (await aioconsole.ainput("\nDeseja editar o arquivo TXT gerado? (s/n): ")).strip().lower()
                if editar == 's':
                    if sistema['android']:
                        print("\nO arquivo TXT corrigido foi salvo no diret√≥rio padr√£o (normalmente Download).")
                        print("Ap√≥s edit√°-lo, reinicie a convers√£o selecionando-o neste script pela op√ß√£o 1 do menu inicial.")
                        await aioconsole.ainput("\nPressione ENTER para retornar ao menu principal...")
                        return ''
                    else:
                        if sistema['windows']:
                            os.startfile(caminho_txt)
                        elif sistema['macos']:
                            subprocess.Popen(["open", caminho_txt])
                        else:
                            subprocess.Popen(["xdg-open", caminho_txt])
                        await aioconsole.ainput("\nEdite o arquivo, salve as altera√ß√µes e pressione ENTER para continuar...")
                return caminho_txt
            elif ext == '.txt':
                # Se o arquivo TXT n√£o cont√©m o sufixo _formatado, corrige-o automaticamente
                if not os.path.basename(caminho).lower().endswith("_formatado.txt"):
                    caminho = verificar_e_corrigir_arquivo(caminho)
                    try:
                        with open(caminho, 'r', encoding='utf-8') as f:
                            texto_original = f.read()
                        texto_formatado = aplicar_formatacao(texto_original)
                        caminho_formatado = os.path.splitext(caminho)[0] + '_formatado.txt'
                        with open(caminho_formatado, 'w', encoding='utf-8') as f:
                            f.write(texto_formatado)
                        print(f'‚úÖ Formata√ß√£o aplicada ao TXT e salva em: {caminho_formatado}')
                        caminho = caminho_formatado
                    except Exception as e:
                        print(f'‚ùå Erro ao aplicar formata√ß√£o ao TXT: {e}')
                return caminho
            else:
                print(f"\n‚ùå Formato n√£o suportado: {ext}")
                print("üí° Apenas arquivos .txt, .pdf e .epub s√£o suportados")
                await asyncio.sleep(1)
        elif escolha.isdigit():
            indice = int(escolha) - 1
            if 0 <= indice < len(arquivos):
                arquivo_selecionado = arquivos[indice]
                caminho_completo = os.path.join(dir_atual, arquivo_selecionado)
                ext = os.path.splitext(arquivo_selecionado)[1].lower()
                if ext == '.pdf':
                    caminho_txt = os.path.splitext(caminho_completo)[0] + '.txt'
                    if not converter_pdf(caminho_completo, caminho_txt):
                        print("\n‚ö†Ô∏è Falha na convers√£o do PDF. Tente outro arquivo.")
                        await asyncio.sleep(1)
                        continue
                    # Corrige o TXT gerado, se necess√°rio
                    caminho_txt = verificar_e_corrigir_arquivo(caminho_txt)
                    editar = (await aioconsole.ainput("\nDeseja editar o arquivo TXT gerado? (s/n): ")).strip().lower()
                    if editar == 's':
                        if sistema['android']:
                            print("\nO arquivo TXT corrigido foi salvo no diret√≥rio padr√£o (normalmente Download).")
                            print("Ap√≥s edit√°-lo, reinicie a convers√£o selecionando-o neste script pela op√ß√£o 1 do menu inicial.")
                            await aioconsole.ainput("\nPressione ENTER para retornar ao menu principal...")
                            return ''
                        else:
                            if sistema['windows']:
                                os.startfile(caminho_txt)
                            elif sistema['macos']:
                                subprocess.Popen(["open", caminho_txt])
                            else:
                                subprocess.Popen(["xdg-open", caminho_txt])
                            await aioconsole.ainput("\nEdite o arquivo, salve as altera√ß√µes e pressione ENTER para continuar...")
                    return caminho_txt
                elif ext == '.txt':
                    if not os.path.basename(caminho_completo).lower().endswith("_formatado.txt"):
                        caminho_completo = verificar_e_corrigir_arquivo(caminho_completo)
                    return caminho_completo
                elif ext == '.epub':
                    caminho_formatado = extrair_texto_de_epub(caminho_completo)
                    try:
                        texto_extraido = ""
                        with zipfile.ZipFile(caminho_completo, 'r') as epub:
                            for nome_arquivo in epub.namelist():
                                if nome_arquivo.endswith('.html') or nome_arquivo.endswith('.xhtml'):
                                    with epub.open(nome_arquivo) as f:
                                        html_bytes = f.read()
                                        try:
                                            html_texto = html_bytes.decode('utf-8')
                                        except UnicodeDecodeError:
                                            html_texto = html_bytes.decode('latin-1')
                                        texto_extraido += html2text.html2text(html_texto) + "\n"
                        nome_base = os.path.splitext(caminho_completo)[0]
                        caminho_txt = nome_base + "_extraido.txt"
                        with open(caminho_txt, 'w', encoding='utf-8') as f:
                            f.write(texto_extraido)

                        caminho_corrigido = verificar_e_corrigir_arquivo(caminho_txt)
                        texto_formatado = aplicar_formatacao(ler_arquivo_texto(caminho_corrigido))
                        caminho_formatado = nome_base + "_formatado.txt"
                        with open(caminho_formatado, 'w', encoding='utf-8') as f:
                            f.write(texto_formatado)

                        editar = (await aioconsole.ainput("\nDeseja editar o arquivo TXT gerado? (s/n): ")).strip().lower()
                        if editar == "s":
                            if sistema["android"]:
                                print("\nO arquivo TXT corrigido foi salvo no diret√≥rio padr√£o (normalmente Download).")
                                print("Ap√≥s edit√°-lo, reinicie a convers√£o selecionando-o novamente.")
                                await aioconsole.ainput("\nPressione ENTER para continuar...")
                                return ""
                            else:
                                if sistema["windows"]:
                                    os.startfile(caminho_formatado)
                                if sistema['windows']:
                                    os.startfile(caminho_formatado)
                                elif sistema['macos']:
                                    subprocess.Popen(["open", caminho_formatado])
                                else:
                                    subprocess.Popen(["xdg-open", caminho_formatado])
                                await aioconsole.ainput("\nPressione ENTER para continuar...")
                                print("Edite o arquivo, salve e pressione ENTER para continuar...")
                        return caminho_formatado  # retorno do extrair_texto_de_epub
                    except Exception as e:
                        print(f"‚ùå Erro ao processar EPUB (zip/html): {e}")
                        await asyncio.sleep(2)
                        return ''
                    except Exception as e:
                        print(f"\n‚ùå Erro ao processar EPUB: {str(e)}")
                        await asyncio.sleep(2)
                        return ''

                else:
                    return caminho_completo
            else:
                print("\n‚ùå Op√ß√£o inv√°lida")
                await asyncio.sleep(1)
        else:
            print("\n‚ùå Op√ß√£o inv√°lida")
            await asyncio.sleep(1)

# ================== FUN√á√ïES DE CONVERS√ÉO TTS ==================

async def iniciar_conversao() -> None:
    """
    Inicia o processo de convers√£o de texto para √°udio de forma concorrente.
    O tamanho dos chunks √© calculado dinamicamente.
    """
    global CANCELAR_PROCESSAMENTO
    CANCELAR_PROCESSAMENTO = False
    
    try:
        caminho_arquivo = await selecionar_arquivo()
        if not caminho_arquivo or CANCELAR_PROCESSAMENTO:
            return

        voz_escolhida = await menu_vozes()
        if voz_escolhida is None or CANCELAR_PROCESSAMENTO:
            return

        print("\nüìñ Lendo arquivo...")
        texto = ler_arquivo_texto(caminho_arquivo)
        if not texto or CANCELAR_PROCESSAMENTO:
            print("\n‚ùå Arquivo vazio ou ileg√≠vel")
            await asyncio.sleep(2)
            return

        print("üîÑ Processando texto...")
        texto_processado = processar_texto(texto)
        
        partes = dividir_texto(texto_processado)
        total_partes = len(partes)
        print(f"\nüìä Texto dividido em {total_partes} parte(s).")
        print("Para interromper a convers√£o a qualquer momento, pressione CTRL + C.\n")

        nome_base = os.path.splitext(os.path.basename(caminho_arquivo))[0]
        nome_base = limpar_nome_arquivo(nome_base)
        diretorio_saida = os.path.join(os.path.dirname(caminho_arquivo), f"{nome_base}_audio")

        if not os.path.exists(diretorio_saida):
            os.makedirs(diretorio_saida)

        temp_files = []
        start_time = time.time()
        semaphore = asyncio.Semaphore(5)  # Limite de 5 tarefas simult√¢neas

        async def processar_chunk(i, parte):
            async with semaphore:
                if CANCELAR_PROCESSAMENTO:
                    return None
                
                saida_temp = os.path.join(diretorio_saida, f"{nome_base}_temp_{i:03d}.mp3")
                temp_files.append(saida_temp)
                
                tentativa = 1
                while tentativa <= MAX_TENTATIVAS:
                    if CANCELAR_PROCESSAMENTO:
                        return None
                    
                    inicio_chunk = time.time()
                    sucesso = await converter_texto_para_audio(parte, voz_escolhida, saida_temp)
                    
                    if sucesso:
                        tempo_chunk = time.time() - inicio_chunk
                        print(f"‚úÖ Parte {i}/{total_partes} | Tentativa {tentativa}/{MAX_TENTATIVAS} | Tempo: {tempo_chunk:.1f}s")
                        return True
                    else:
                        print(f"üîÑ Tentativa {tentativa}/{MAX_TENTATIVAS} falhou para parte {i}. Reiniciando...")
                        tentativa += 1
                        await asyncio.sleep(2)  # Intervalo entre tentativas
                
                print(f"‚ùå Falha definitiva na parte {i} ap√≥s {MAX_TENTATIVAS} tentativas")
                return False

        tasks = [processar_chunk(i+1, p) for i, p in enumerate(partes)]
        results = await asyncio.gather(*tasks)
        
        # Verificar se todas as partes foram convertidas
        if not all(results):
            print("\n‚ö†Ô∏è Algumas partes falharam. N√£o √© poss√≠vel unificar.")
            return
        
        if not CANCELAR_PROCESSAMENTO and any(results):
            print("\nüîÑ Unificando arquivos...")
            arquivo_final = os.path.join(diretorio_saida, f"{nome_base}.mp3")
            
            if unificar_audio(temp_files, arquivo_final):
                for f in temp_files:
                    if os.path.exists(f):
                        os.remove(f)
                overall_time = time.time() - start_time
                print(f"\nüéâ Convers√£o conclu√≠da em {overall_time:.1f} s! Arquivo final: {arquivo_final}")
                
                # Pergunta se deseja melhorar o √°udio
                melhorar = (await aioconsole.ainput("\nDeseja melhorar o √°udio gerado (ajustar velocidade)? (s/n): ")).strip().lower()
                if melhorar == 's':
                    await processar_melhorar_audio(arquivo_final)
            else:
                print("\n‚ùå Falha na unifica√ß√£o dos arquivos.")

        await aioconsole.ainput("\nPressione ENTER para continuar...")

    except asyncio.CancelledError:
        print("\nüö´ Opera√ß√£o cancelada pelo usu√°rio")
    finally:
        CANCELAR_PROCESSAMENTO = True
        if 'temp_files' in locals():
            for f in temp_files:
                if os.path.exists(f):
                    os.remove(f)
        await asyncio.sleep(1)

async def main() -> None:
    """Fun√ß√£o principal do programa."""
    verificar_dependencias()
    
    # Configura pol√≠tica de event loop para Windows
    if sys.platform == 'win32':
        asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
    
    while True:
        opcao = await menu_principal()
        if opcao == '1':
            await iniciar_conversao()
        elif opcao == '2':
            while True:
                voz_escolhida = await menu_vozes()
                if voz_escolhida is None:
                    break
                print(f"\nüéôÔ∏è Testando voz: {voz_escolhida}")
                await testar_voz(voz_escolhida)
        elif opcao == '3':
            await menu_melhorar_audio()
        elif opcao == '4':
            await exibir_ajuda()
        elif opcao == '5':
            await atualizar_script()
        elif opcao == '6':
            await menu_converter_mp3_para_mp4()
        elif opcao == '7':
            print("\nüëã Obrigado por usar o Conversor TTS Completo!")
            sys.exit(0)

asyncio.run(main())

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è Programa interrompido pelo usu√°rio.")
    except Exception as e:
        print(f"\n‚ùå Erro inesperado: {str(e)}")


# === Fun√ß√µes para EPUB adicionadas ===
from bs4 import BeautifulSoup

def convert_epub_to_txt(epub_path, output_path=None):
    """
    Converte um arquivo ePub para TXT
    """
    try:
        # Verifica se o arquivo existe
        if not os.path.exists(epub_path):
            print(f"Erro: Arquivo '{epub_path}' n√£o encontrado.")
            return False
        
        # Define o nome do arquivo de sa√≠da
        if output_path is None:
            output_path = os.path.splitext(epub_path)[0] + ".txt"
        
        # Extrai o conte√∫do do ePub (que √© um arquivo zip)
        with zipfile.ZipFile(epub_path, 'r') as epub:
            # Encontra todos os arquivos HTML/XHTML no ePub
            html_files = [f for f in epub.namelist() 
                         if f.lower().endswith(('.html', '.xhtml', '.htm'))]
            
            # Ordena os arquivos para manter a ordem dos cap√≠tulos
            html_files.sort()
            
            # Processa cada arquivo HTML
            full_text = ""
            for html_file in html_files:
                with epub.open(html_file) as f:
                    html_content = f.read().decode('utf-8')
                    
                    # Usa BeautifulSoup para limpar o HTML
                    soup = BeautifulSoup(html_content, 'html.parser')
                    
                    # Remove scripts e estilos
                    for script in soup(["script", "style"]):
                        script.decompose()
                    
                    # Converte HTML para texto usando html2text
                    h = html2text.HTML2Text()
                    h.ignore_links = True
                    h.ignore_images = True
                    h.ignore_emphasis = True
                    text = h.handle(str(soup))
                    
                    full_text += text + "\n\n"
        
        # Salva o texto em um arquivo
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(full_text)
            
        print(f"Convers√£o conclu√≠da! Arquivo salvo em: {output_path}")
        return True
        
    except Exception as e:
        print(f"Erro durante a convers√£o: {str(e)}")
        return False
    
    epub_path = sys.argv[1]
    output_path = sys.argv[2] if len(sys.argv) > 2 else None
    
    convert_epub_to_txt(epub_path, output_path)

if __name__ == "__main__":
    asyncio.run(menu_principal())
