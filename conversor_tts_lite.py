#!/usr/bin/env python3
import os
import sys
import subprocess
import asyncio
import re
import signal
from pathlib import Path

# =============================================================================
# CONFIGURA√á√ÉO E CONSTANTES
# =============================================================================
# Vozes dispon√≠veis para convers√£o
VOZES_PT_BR = [
    "pt-BR-ThalitaMultilingualNeural",  # Voz padr√£o
    "pt-BR-FranciscaNeural",
    "pt-BR-AntonioNeural"
]

# Diret√≥rios e configura√ß√µes de encoding e buffer
ENCODINGS_TENTATIVAS = ['utf-8', 'utf-16', 'iso-8859-1', 'cp1252']
BUFFER_IO = 32768

# Global para interrup√ß√£o via sinal (Ctrl+C)
interrupcao_requisitada = False

# =============================================================================
# FUN√á√ïES DE VERIFICA√á√ÉO DE AMBIENTE E DEPEND√äNCIAS
# =============================================================================
def verificar_sistema() -> bool:
    """
    Verifica se o script est√° sendo executado no ambiente Termux.
    Retorna True se estiver no Termux, False caso contr√°rio.
    """
    print("\nüîç Verificando ambiente de execu√ß√£o...")
    if 'TERMUX_VERSION' in os.environ:
        print("‚úÖ Executando no Termux")
        return True
    else:
        print("‚ÑπÔ∏è Executando em ambiente n√£o-Termux")
        return False

def instalar_dependencia_termux(pkg: str) -> None:
    """
    Verifica e instala um pacote do Termux, se necess√°rio.
    """
    try:
        subprocess.run(['pkg', 'list-installed', pkg], check=True, capture_output=True)
        print(f"‚úÖ Pacote Termux {pkg} j√° est√° instalado")
    except subprocess.CalledProcessError:
        print(f"‚ö†Ô∏è Instalando pacote Termux {pkg}...")
        try:
            subprocess.run(['pkg', 'install', '-y', pkg], check=True)
            print(f"‚úÖ Pacote Termux {pkg} instalado com sucesso!")
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Erro ao instalar pacote Termux {pkg}: {e}")
            sys.exit(1)

def instalar_dependencia_python(nome_pkg: str, pip_nome: str) -> None:
    """
    Tenta importar o pacote Python e, se n√£o estiver instalado, realiza a instala√ß√£o.
    """
    try:
        __import__(nome_pkg)
        print(f"‚úÖ {nome_pkg} j√° est√° instalado")
    except ImportError:
        print(f"\n‚ö†Ô∏è Instalando {nome_pkg}...")
        try:
            subprocess.check_call([sys.executable, "-m", "pip", "install", "--user", pip_nome])
            print(f"‚úÖ {nome_pkg} instalado com sucesso!")
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Erro ao instalar {nome_pkg}: {e}")
            print(f"üí° Tente instalar manualmente com: pip install --user {pip_nome}")
            sys.exit(1)
        except Exception as e:
            print(f"‚ùå Erro inesperado ao instalar {nome_pkg}: {e}")
            sys.exit(1)

def verificar_dependencias() -> None:
    """
    Verifica e instala as depend√™ncias necess√°rias tanto para Termux quanto para Python.
    """
    is_termux = verificar_sistema()
    if is_termux:
        for pkg in ['python', 'python-pip', 'git']:
            instalar_dependencia_termux(pkg)
    
    dependencias_python = {
        'edge-tts': 'edge-tts',
        'langdetect': 'langdetect',
        'unidecode': 'unidecode',
        'num2words': 'num2words'
        # Removido googletrans para evitar atrasos
    }
    for nome_pkg, pip_nome in dependencias_python.items():
        instalar_dependencia_python(nome_pkg, pip_nome)

# Executa a verifica√ß√£o de depend√™ncias antes de importar m√≥dulos de terceiros
verificar_dependencias()

# =============================================================================
# IMPORTA√á√ÉO DE M√ìDULOS TERCEIRIZADOS
# =============================================================================
import asyncio
import edge_tts
from unidecode import unidecode
import chardet

# Importa num2words
try:
    from num2words import num2words
    print("‚úÖ num2words importado com sucesso!")
except ImportError:
    print("\n‚ùå Erro ao importar num2words. Tente instalar manualmente:")
    print("pip install --user num2words")
    sys.exit(1)

# Importa langdetect e configura semente
try:
    from langdetect import detect, DetectorFactory
    DetectorFactory.seed = 0
    LANG_DETECT_AVAILABLE = True
except ImportError:
    print("\n‚ö†Ô∏è O m√≥dulo langdetect n√£o est√° instalado.")
    print("Para instalar, execute: pip install langdetect")
    LANG_DETECT_AVAILABLE = False

# =============================================================================
# FUN√á√ïES UTILIT√ÅRIAS
# =============================================================================
def limpar_tela() -> None:
    """Limpa a tela do terminal."""
    os.system("clear" if os.name == "posix" else "cls")

def obter_opcao(prompt: str, opcoes: list) -> str:
    """
    Solicita ao usu√°rio uma entrada que esteja dentre as op√ß√µes v√°lidas.
    """
    while True:
        escolha = input(prompt).strip()
        if escolha in opcoes:
            return escolha
        print("‚ö†Ô∏è Op√ß√£o inv√°lida! Tente novamente.")

def gravar_progresso(arquivo_progresso: str, indice: int) -> None:
    """Grava o √≠ndice da √∫ltima parte processada em arquivo."""
    with open(arquivo_progresso, 'w') as f:
        f.write(str(indice))

def ler_progresso(arquivo_progresso: str) -> int:
    """L√™ o √≠ndice da √∫ltima parte processada a partir do arquivo de progresso."""
    try:
        with open(arquivo_progresso, 'r') as f:
            return int(f.read().strip())
    except Exception:
        return 0

def limpar_nome_arquivo(nome: str) -> str:
    """
    Remove ou substitui caracteres inv√°lidos em sistemas de arquivos,
    como : / \ * ? " < > | etc. 
    """
    caracteres_invalidos = r'\/:*?"<>|'
    for c in caracteres_invalidos:
        nome = nome.replace(c, '-')
    return nome.strip()

# =============================================================================
# PROCESSAMENTO DE TEXTO
# =============================================================================
def romano_para_decimal(romano: str) -> int:
    """
    Converte n√∫meros romanos para decimal.
    """
    valores = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    decimal = 0
    prev_value = 0
    for char in reversed(romano.upper()):
        curr_value = valores.get(char, 0)
        decimal = decimal + curr_value if curr_value >= prev_value else decimal - curr_value
        prev_value = curr_value
    return decimal

def converter_ordinal(match: re.Match) -> str:
    """
    Converte n√∫meros ordinais para texto, utilizando num2words.
    """
    numero = int(match.group(1))
    sufixo = match.group(2)
    if sufixo.lower() in ['¬∫', '¬™']:
        try:
            return num2words(numero, lang='pt_BR', ordinal=True)
        except Exception:
            return match.group(0)
    return match.group(0)

def validar_texto_pt_br(texto: str) -> bool:
    """
    Valida se o texto est√° em portugu√™s e trata casos de texto vazio.
    Caso a detec√ß√£o esteja indispon√≠vel ou o idioma n√£o seja pt,
    solicita confirma√ß√£o ao usu√°rio.
    """
    if not texto.strip():
        print("\n‚ö†Ô∏è Aviso: O texto est√° vazio!")
        return False

    if LANG_DETECT_AVAILABLE:
        try:
            idioma = detect(texto)
            if idioma != 'pt':
                print(f"\n‚ö†Ô∏è Aviso: O texto pode n√£o estar em portugu√™s (idioma detectado: {idioma})")
                print("Deseja continuar mesmo assim?")
                opcao = obter_opcao("\nüîπ Sua escolha ([1] Sim / [2] N√£o): ", ['1', '2'])
                return opcao == '1'
        except Exception as e:
            print(f"\n‚ö†Ô∏è Aviso: N√£o foi poss√≠vel detectar o idioma automaticamente: {e}")
    else:
        print("\n‚ö†Ô∏è Aviso: A detec√ß√£o de idioma n√£o est√° dispon√≠vel.")
        print("Deseja continuar mesmo assim?")
        opcao = obter_opcao("\nüîπ Sua escolha ([1] Sim / [2] N√£o): ", ['1', '2'])
        return opcao == '1'
    return True

def otimizar_texto_tts(texto: str) -> str:
    """
    Realiza otimiza√ß√µes no texto para melhorar a pron√∫ncia na convers√£o TTS:
      - Remove ou substitui caracteres problem√°ticos.
      - Converte n√∫meros romanos, ordinais e algarismos.
      - Substitui palavras e s√≠mbolos problem√°ticos.
      - Ajusta pausas na pontua√ß√£o.
    """
    # Limpeza de caracteres que podem causar erros no TTS
    caracteres_problematicos = {
        "¬©": " copyright ",
        "¬Æ": " marca registrada ",
        "‚Äì": "-",    # travess√£o curto
        "‚Äî": "-",    # travess√£o longo
        "‚Äú": '"',
        "‚Äù": '"',
        "‚Äò": "'",
        "‚Äô": "'",
        "\ufeff": "",  # BOM
        "‚Ä¶": "..."
    }
    for chave, valor in caracteres_problematicos.items():
        texto = texto.replace(chave, valor)

    # Converter cap√≠tulos e t√≠tulos com algarismos romanos
    texto = re.sub(r'(CAP√çTULO|Cap√≠tulo|T√çTULO|T√≠tulo|Parte|PARTE|Livro|LIVRO)\s+([IVXLCDM]+)',
                   lambda m: f"{m.group(1)} {romano_para_decimal(m.group(2))}",
                   texto)
    # Converter n√∫meros ordinais para texto
    texto = re.sub(r'(\d+)([¬∫¬™])', converter_ordinal, texto)
    # Converter n√∫meros romanos isolados
    texto = re.sub(r'\b([IVXLCDM]+)\b',
                   lambda m: str(romano_para_decimal(m.group(1))),
                   texto)

    # Dicion√°rio de substitui√ß√µes para otimiza√ß√£o de pron√∫ncia
    substituicoes = {
        'm√°s': 'mas', 'p√¥r': 'por', 't√™m': 'tem',
        '√†': 'a', '√†s': 'as', '√©': 'eh',
        'h√°': 'ha', 'atrav√©s': 'atraves',
        'ap√≥s': 'apos', 'at√©': 'ate',
        '1¬∫': 'primeiro', '2¬∫': 'segundo', '3¬∫': 'terceiro',
        'dr.': 'doutor', 'sr.': 'senhor', 'sra.': 'senhora',
        'prof.': 'professor', 'profa.': 'professora',
        '%': ' porcento', '&': ' e ', '@': ' arroba ', '#': ' hashtag ',
        'pra': 'para', 'pro': 'para o',
        'vc': 'voc√™', 'tb': 'tamb√©m',
        'q': 'que', 'td': 'tudo'
    }
    # Aplicar substitui√ß√µes
    texto = texto.lower()
    for original, corrigida in substituicoes.items():
        texto = re.sub(rf'\b{original}\b', corrigida, texto, flags=re.IGNORECASE)

    # Converter algarismos para extenso
    texto = re.sub(r'\d+', lambda m: num2words(int(m.group()), lang='pt_BR'), texto)

    # Ajustar pausas e pontua√ß√£o
    pontuacoes = {'.': '. ', ',': ', ', ';': '; ', ':': ': ', '!': '! ', '?': '? ', '...': '... '}
    for sinal, substituicao in pontuacoes.items():
        texto = texto.replace(sinal, substituicao)
    texto = re.sub(r'\.{3,}', '... ', texto)
    texto = re.sub(r'\s+', ' ', texto)
    texto = re.sub(r'\s+([.,!?;:])', r'\1', texto)
    texto = re.sub(r'([.,!?;:])(?=\S)', r'\1 ', texto)
    
    return texto.strip()

# =============================================================================
# PROCESSAMENTO DE √ÅUDIO
# =============================================================================
def tratar_sinal_interrupcao(signum, frame) -> None:
    """
    Manipulador de sinal para Ctrl+C: ativa a flag global de interrup√ß√£o.
    """
    global interrupcao_requisitada
    interrupcao_requisitada = True
    print("\n\nüõë Pressione Ctrl+C novamente para interromper a convers√£o...")

signal.signal(signal.SIGINT, tratar_sinal_interrupcao)

async def tratar_interrupcao(temp_files: list, arquivo_saida: str) -> bool:
    """
    Trata a interrup√ß√£o da convers√£o, oferecendo op√ß√µes para o usu√°rio:
      1. Manter arquivos parciais separados.
      2. Unificar arquivos convertidos.
      3. Excluir arquivos convertidos.
    Tamb√©m pergunta se o registro de progresso deve ser mantido.
    """
    print("\n\nüõë Convers√£o interrompida!")
    print("\nEscolha uma op√ß√£o:")
    print("[1] Manter arquivos parciais separados")
    print("[2] Unificar arquivos convertidos")
    print("[3] Excluir arquivos convertidos")
    opcao = obter_opcao("\nüîπ Sua escolha ([1/2/3]): ", ['1', '2', '3'])

    if opcao == '1':
        print("\n‚úÖ Arquivos parciais mantidos separadamente.")
    elif opcao == '2':
        print("\nüîÑ Unificando arquivos convertidos...")
        try:
            with open(arquivo_saida, 'wb') as outfile:
                for temp_file in temp_files:
                    if os.path.exists(temp_file):
                        with open(temp_file, 'rb') as infile:
                            while True:
                                chunk = infile.read(BUFFER_IO)
                                if not chunk:
                                    break
                                outfile.write(chunk)
                        os.remove(temp_file)
                        print(f"üóëÔ∏è Arquivo tempor√°rio removido: {temp_file}")
            print("‚úÖ Arquivos unificados com sucesso!")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao unificar arquivos: {e}")
    else:
        print("\nüóëÔ∏è Excluindo arquivos convertidos...")
        for temp_file in temp_files:
            try:
                if os.path.exists(temp_file):
                    os.remove(temp_file)
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao excluir {temp_file}: {e}")
        print("‚úÖ Arquivos exclu√≠dos com sucesso!")

    # Gerenciar arquivo de progresso
    arquivo_progresso = f"{arquivo_saida}.progress"
    if os.path.exists(arquivo_progresso):
        print("\nüíæ Deseja manter o registro de progresso para retomar a convers√£o posteriormente?")
        opcao_prog = obter_opcao("\nüîπ Sua escolha ([1] Sim / [2] N√£o): ", ['1', '2'])
        if opcao_prog == '2':
            try:
                os.remove(arquivo_progresso)
                print("‚úÖ Registro de progresso apagado com sucesso!")
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao apagar registro de progresso: {e}")
        else:
            print("‚úÖ Registro de progresso mantido para continua√ß√£o posterior.")
    limpar_tela()
    return False

async def processar_audio(texto: str, arquivo_saida: str, voz: str, chunk_size: int = 2000) -> bool:
    """
    Processa o texto em chunks para convers√£o em √°udio via edge-tts.
    Gera arquivos tempor√°rios para cada parte e, dependendo da escolha do usu√°rio,
    unifica os arquivos ao final.
    """
    temp_files = []
    # Define nome base a partir da primeira linha do texto
    primeira_linha = texto.strip().split('\n')[0].strip()
    if primeira_linha:
        # Limpa caracteres proibidos no nome do arquivo
        linha_limpa = limpar_nome_arquivo(primeira_linha)
        nome_base = Path(arquivo_saida).parent / linha_limpa
        arquivo_saida = f"{nome_base}.mp3"

    # Escolha de unifica√ß√£o de arquivos
    print("\nüì¶ Prefer√™ncia de arquivos:")
    print("[Enter/N] Unificar arquivos e excluir partes (padr√£o)")
    print("[S] Manter arquivos separados")
    opcao = input("\nüîπ Sua escolha: ").strip().upper()
    manter_separado = (opcao == 'S')

    # Valida√ß√£o do idioma do texto
    if not validar_texto_pt_br(texto):
        print("\nüõë Convers√£o cancelada pelo usu√°rio.")
        return False

    # Otimiza o texto para TTS (j√° com limpeza dos caracteres problem√°ticos)
    texto = otimizar_texto_tts(texto)

    # Reseta flag de interrup√ß√£o
    global interrupcao_requisitada
    interrupcao_requisitada = False

    # Determina o tamanho dos chunks de forma adaptativa
    chunk_size = max(2000, min(len(texto) // 10, 5000))
    partes = [texto[i:i + chunk_size] for i in range(0, len(texto), chunk_size)]
    total_partes = len(partes)
    print(f"\nüîÑ Processando {total_partes} partes...")
    print("\nPressione Ctrl+C para interromper a convers√£o a qualquer momento.")

    # Gerencia progresso, se existir
    arquivo_progresso = f"{arquivo_saida}.progress"
    indice_inicial = ler_progresso(arquivo_progresso)
    if indice_inicial > 0:
        print(f"\nüìù Retomando a partir da parte {indice_inicial + 1}")

    for i, parte in enumerate(partes[indice_inicial:], start=indice_inicial + 1):
        if interrupcao_requisitada:
            gravar_progresso(arquivo_progresso, i - 1)
            await tratar_interrupcao(temp_files, arquivo_saida)
            limpar_tela()
            return False

        print(f"\rüìä Progresso: {i}/{total_partes} ({int(i / total_partes * 100)}%) " + "=" * (i * 20 // total_partes) + ">", end="")

        max_tentativas = 5
        for tentativa in range(1, max_tentativas + 1):
            try:
                comunicador = edge_tts.Communicate(parte.strip(), voz)
                arquivo_temp = f"{arquivo_saida}.part{i:03d}.mp3"
                await comunicador.save(arquivo_temp)
                temp_files.append(arquivo_temp)
                gravar_progresso(arquivo_progresso, i)
                break
            except Exception as e:
                if tentativa < max_tentativas:
                    tempo_espera = 2 ** tentativa
                    print(f"\n‚ö†Ô∏è Erro ao processar parte {i}. Tentativa {tentativa}/{max_tentativas}. Aguardando {tempo_espera}s...")
                    await asyncio.sleep(tempo_espera)
                else:
                    print(f"\n‚ö†Ô∏è Erro ao processar parte {i} ap√≥s {max_tentativas} tentativas: {e}")
                    continue

    # Combina os arquivos caso o usu√°rio n√£o deseje mant√™-los separados
    if not interrupcao_requisitada:
        if not manter_separado:
            print("\nüì¶ Combinando arquivos...")
            try:
                with open(arquivo_saida, 'wb') as outfile:
                    for temp_file in temp_files:
                        if os.path.exists(temp_file):
                            with open(temp_file, 'rb') as infile:
                                while True:
                                    chunk = infile.read(BUFFER_IO)
                                    if not chunk:
                                        break
                                    outfile.write(chunk)
                            os.remove(temp_file)
                            print(f"\rüóëÔ∏è Arquivo tempor√°rio removido: {temp_file}", end="")
                if os.path.exists(arquivo_progresso):
                    os.remove(arquivo_progresso)
                print("\n‚úÖ Convers√£o conclu√≠da! Arquivo unificado criado.")
            except Exception as e:
                print(f"\n‚ö†Ô∏è Erro ao unificar arquivos: {e}")
        else:
            print("\n‚úÖ Convers√£o conclu√≠da! Arquivos mantidos separados.")
        return True
    return False

def ler_arquivo(caminho: str) -> str:
    try:
        with open(caminho, 'rb') as f:
            conteudo_bruto = f.read()
            resultado = chardet.detect(conteudo_bruto)
            encoding_detectado = resultado.get('encoding')

            if encoding_detectado is None and b'\x00' in conteudo_bruto:
                # For√ßa UTF-16 LE se encontrar alta presen√ßa de bytes nulos (caracter√≠stica de UTF-16)
                encoding_detectado = 'utf-16-le'

            if encoding_detectado:
                return conteudo_bruto.decode(encoding_detectado)

    except Exception as e:
        print(f"‚ùå Erro ao ler o arquivo: {e}")

    print(f"‚ùå N√£o foi poss√≠vel ler o arquivo {caminho}. Verifique o encoding.")
    return None


def atualizar_script():
    """
    Atualiza o script baixando a vers√£o mais recente diretamente do GitHub.
    Sobrescreve o arquivo atual e oferece op√ß√£o de reiniciar automaticamente.
    """
    import shutil

    url = "https://raw.githubusercontent.com/JonJonesBR/Conversor_TTS/main/conversor_tts_lite.py"
    arquivo_temp = "conversor_tts_lite_temp.py"
    arquivo_atual = sys.argv[0]

    print("\nüîÑ Iniciando atualiza√ß√£o do Conversor TTS...")

    try:
        subprocess.run(["curl", "-o", arquivo_temp, url], check=True)
        print("‚úÖ Nova vers√£o baixada com sucesso.")
    except subprocess.CalledProcessError:
        print("‚ùå Erro ao baixar com curl. Tentando com wget...")
        try:
            subprocess.run(["wget", "-O", arquivo_temp, url], check=True)
            print("‚úÖ Nova vers√£o baixada com sucesso.")
        except subprocess.CalledProcessError:
            print("‚ùå Falha ao baixar a atualiza√ß√£o. Verifique sua conex√£o com a internet.")
            return

    try:
        shutil.move(arquivo_temp, arquivo_atual)
        print("‚úÖ Atualiza√ß√£o conclu√≠da com sucesso!")
    except Exception as e:
        print(f"‚ùå Erro ao substituir o arquivo: {e}")
        return

    opcao = input("\nüîÑ Deseja reiniciar o script agora? (S/N): ").strip().lower()
    if opcao == 's':
        print("üîÑ Reiniciando...")
        os.execv(sys.executable, [sys.executable] + sys.argv)



def exibir_menu() -> str:
    print("\n" + "=" * 60)
    print("""
    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
    ‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
       ‚ñà‚ñà‚ïë      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
       ‚ñà‚ñà‚ïë      ‚ñà‚ñà‚ïë   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë
       ‚ñà‚ñà‚ïë      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
       ‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)
    print("=" * 60)
    print("\n\033[1;36;1müéØ MENU PRINCIPAL\033[0m")
    print("-" * 50)
    print("\n\033[1;32;1m[1] üöÄ INICIAR")
    print("\033[1;34;1m[2] üéôÔ∏è VOZES")
    print("\033[1;33;1m[3] ‚ùì AJUDA")
    print("\033[1;35;1m[4] üîÑ ATUALIZAR SCRIPT")
    print("\033[1;31;1m[5] üö™ SAIR\033[0m")
    print("-" * 50)
    return obter_opcao("\n\033[1;36;1müîπ Escolha: \033[0m", ['1', '2', '3', '4', '5'])



async def main() -> None:
    while True:
        opcao = exibir_menu()
        if opcao == '1':
            await converter_audio()
        elif opcao == '2':
            await testar_vozes()
        elif opcao == '3':
            exibir_ajuda()
        elif opcao == '4':
            atualizar_script()
        elif opcao == '5':
            print("\nüëã Obrigado por usar o Conversor TTS Lite!")
            break

# =============================================================================
# INTERFACE DO USU√ÅRIO (CLI)
# =============================================================================
def exibir_menu() -> str:
    """Exibe o menu principal e retorna a op√ß√£o escolhida."""
    print("\n" + "=" * 60)
    print("""
    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
    ‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
       ‚ñà‚ñà‚ïë      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
       ‚ñà‚ñà‚ïë      ‚ñà‚ñà‚ïë   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë
       ‚ñà‚ñà‚ïë      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
       ‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)
    print("=" * 60)
    print("\n\033[1;36;1müéØ MENU PRINCIPAL\033[0m")
    print("-" * 50)
    print("\n\033[1;32;1m[1] üöÄ INICIAR")
    print("\033[1;34;1m[2] üéôÔ∏è VOZES")
    print("\033[1;33;1m[3] ‚ùì AJUDA")
    print("\033[1;31;1m[4] üö™ SAIR\033[0m")
    print("-" * 50)
    return obter_opcao("\n\033[1;36;1müîπ Escolha: \033[0m", ['1', '2', '3', '4'])

def exibir_ajuda() -> None:
    """Exibe o guia de uso do conversor TTS."""
    print("\n" + "-" * 50)
    print("\033[1;36;1müìö GUIA DO CONVERSOR TTS\033[0m")
    print("-" * 50)
    print("\n\033[1;33;1m1Ô∏è‚É£ PREPARA√á√ÉO")
    print("\033[1;37;1m‚Ä¢ Salve seu texto em um arquivo .txt")
    print("\033[1;37;1m‚Ä¢ Coloque-o na pasta Downloads")
    
    print("\n\033[1;33;1m2Ô∏è‚É£ CONVERS√ÉO")
    print("\033[1;37;1m‚Ä¢ Selecione 'Iniciar'")
    print("\033[1;37;1m‚Ä¢ Escolha o arquivo desejado")
    print("\033[1;37;1m‚Ä¢ Selecione a voz")
    
    print("\n\033[1;33;1m3Ô∏è‚É£ RECURSOS")
    print("\033[1;37;1m‚Ä¢ Convers√£o de n√∫meros para texto")
    print("\033[1;37;1m‚Ä¢ Otimiza√ß√µes para o portugu√™s")
    print("\033[1;37;1m‚Ä¢ Processamento de textos longos")
    print("\033[1;37;1m‚Ä¢ Detec√ß√£o de idioma (para avisar se n√£o for PT-BR)")
    
    print("\n\033[1;33;1m4Ô∏è‚É£ DICAS")
    print("\033[1;37;1m‚Ä¢ Teste diferentes vozes")
    print("\033[1;37;1m‚Ä¢ Use Ctrl+C para interromper a convers√£o")
    print("\033[1;37;1m‚Ä¢ O √°udio ser√° salvo na pasta Downloads")
    
    input("\n\033[1;36;1müîπ Pressione Enter para voltar...\033[0m")
    limpar_tela()

def escolher_voz() -> str:
    """Exibe as op√ß√µes de voz e retorna a voz escolhida."""
    print("\n" + "-" * 50)
    print("\033[1;36;1müéôÔ∏è ESCOLHA A VOZ PARA A CONVERS√ÉO\033[0m")
    print("\n\033[1;33;1m‚≠ê A voz padr√£o √© 'Thalita' - otimizada para m√∫ltiplos idiomas\033[0m")
    for indice, voz in enumerate(VOZES_PT_BR, start=1):
        detalhe = " (Voz padr√£o)" if indice == 1 else ""
        print(f"\033[1;32;1m  [{indice}] {voz}{detalhe}\033[0m")
    escolha = input("\n\033[1;36;1müîπ Digite o n√∫mero da voz desejada: \033[0m").strip()
    while not (escolha.isdigit() and 1 <= int(escolha) <= len(VOZES_PT_BR)):
        print("\033[1;31;1m‚ö†Ô∏è Op√ß√£o inv√°lida! Escolha um n√∫mero da lista.\033[0m")
        escolha = input("\n\033[1;36;1müîπ Digite o n√∫mero da voz desejada: \033[0m").strip()
    return VOZES_PT_BR[int(escolha) - 1]

# =============================================================================
# FUN√á√ïES PRINCIPAIS DE CONVERS√ÉO E TESTES
# =============================================================================
async def converter_audio() -> None:
    """
    Fun√ß√£o principal para converter um arquivo de texto em √°udio.
    L√™ o arquivo, permite a escolha de voz, processa o texto e gera o √°udio.
    """
    limpar_tela()
    print("\nüìñ Conversor de Texto para Fala - Modo Leve\n")

    # Determina o diret√≥rio padr√£o de arquivos TXT
    diretorio_padrao = "/storage/emulated/0/Download"
    if not os.path.exists(diretorio_padrao):
        diretorio_padrao = os.path.expanduser("~/storage/downloads")
        if not os.path.exists(diretorio_padrao):
            diretorio_padrao = os.path.expanduser("~")

    if not os.path.exists(diretorio_padrao):
        print(f"‚ö†Ô∏è Diret√≥rio n√£o encontrado: {diretorio_padrao}")
        print("‚ÑπÔ∏è Dica: Verifique se o Termux tem permiss√£o de acesso ao armazenamento (termux-setup-storage).")
        return

    # Lista arquivos TXT dispon√≠veis
    arquivos_txt = [f for f in os.listdir(diretorio_padrao) if f.endswith('.txt')]
    if not arquivos_txt:
        print("‚ö†Ô∏è Nenhum arquivo TXT encontrado no diret√≥rio de downloads!")
        return

    print("üìÑ Arquivos TXT dispon√≠veis:")
    for indice, arquivo in enumerate(arquivos_txt, start=1):
        print(f"[{indice}] {arquivo}")

    opcao = input("\nüîπ Digite o n√∫mero do arquivo desejado: ").strip()
    while not (opcao.isdigit() and 1 <= int(opcao) <= len(arquivos_txt)):
        print("‚ö†Ô∏è Op√ß√£o inv√°lida! Escolha um n√∫mero da lista.")
        opcao = input("\nüîπ Digite o n√∫mero do arquivo desejado: ").strip()
    arquivo_selecionado = arquivos_txt[int(opcao) - 1]

    caminho_completo = os.path.join(diretorio_padrao, arquivo_selecionado)
    print(f"\nüìÑ Lendo arquivo: {arquivo_selecionado}")
    texto = ler_arquivo(caminho_completo)
    if not texto:
        return

    voz = escolher_voz()
    nome_base = Path(caminho_completo).stem
    diretorio_saida = os.path.join(diretorio_padrao, f"{nome_base}_audio")
    os.makedirs(diretorio_saida, exist_ok=True)
    arquivo_saida = os.path.join(diretorio_saida, f"{nome_base}.mp3")

    await processar_audio(texto, arquivo_saida, voz)
    print(f"\nüìÇ Arquivos salvos em: {diretorio_saida}")
    input("\nüîπ Pressione Enter para voltar ao menu...")
    limpar_tela()

async def testar_vozes() -> None:
    """
    Gera arquivos de teste para cada voz dispon√≠vel, salvando-os em um diret√≥rio de testes.
    """
    limpar_tela()
    print("\nüîä Gerando arquivos de teste para cada voz...\n")
    diretorio_testes = "vozes_teste"
    os.makedirs(diretorio_testes, exist_ok=True)
    texto_teste = "Este √© um teste da voz para convers√£o de texto em fala."
    for voz in VOZES_PT_BR:
        print(f"\nüéôÔ∏è Testando voz: {voz}")
        arquivo_mp3 = os.path.join(diretorio_testes, f"{voz}.mp3")
        comunicador = edge_tts.Communicate(texto_teste, voz)
        await comunicador.save(arquivo_mp3)
        print(f"‚úÖ Arquivo salvo: {arquivo_mp3}")
    print("\n‚úÖ Testes conclu√≠dos!")
    print(f"üìÇ Arquivos salvos em: {diretorio_testes}")
    input("\nüîπ Pressione Enter para voltar ao menu...")
    limpar_tela()

#async def main() -> None:
    """
    Fun√ß√£o principal que exibe o menu e direciona para as fun√ß√µes correspondentes.
    """
    while True:
        opcao = exibir_menu()
        if opcao == '1':
            await converter_audio()
        elif opcao == '2':
            await testar_vozes()
        elif opcao == '3':
            exibir_ajuda()
        elif opcao == '4':
            print("\nüëã Obrigado por usar o Conversor TTS Lite!")
            break

if __name__ == '__main__':
    asyncio.run(main())