import os
import sys
import subprocess

def verificar_sistema():
    print("\nüîç Verificando ambiente de execu√ß√£o...")
    is_termux = 'TERMUX_VERSION' in os.environ
    if is_termux:
        print("‚úÖ Executando no Termux")
        return True
    else:
        print("‚ÑπÔ∏è Executando em ambiente n√£o-Termux")
        return False

def verificar_dependencias():
    print("\nüîç Verificando depend√™ncias necess√°rias...")
    is_termux = verificar_sistema()
    
    # Pacotes espec√≠ficos do Termux que precisam ser instalados
    if is_termux:
        termux_pkgs = ['python', 'python-pip', 'git']
        for pkg in termux_pkgs:
            try:
                subprocess.run(['pkg', 'list-installed', pkg], check=True, capture_output=True)
                print(f"‚úÖ Pacote Termux {pkg} j√° est√° instalado")
            except subprocess.CalledProcessError:
                print(f"‚ö†Ô∏è Instalando pacote Termux {pkg}...")
                try:
                    subprocess.run(['pkg', 'install', '-y', pkg], check=True)
                    print(f"‚úÖ Pacote Termux {pkg} instalado com sucesso!")
                except subprocess.CalledProcessError as e:
                    print(f"‚ùå Erro ao instalar pacote Termux {pkg}: {e}")
                    sys.exit(1)
    
    # Depend√™ncias Python
    dependencias = {
        'edge-tts': 'edge-tts',
        'langdetect': 'langdetect',
        'unidecode': 'unidecode',
        'num2words': 'num2words'
    }

    for pacote, pip_nome in dependencias.items():
        try:
            __import__(pacote)
            print(f"‚úÖ {pacote} j√° est√° instalado")
        except ImportError:
            print(f"\n‚ö†Ô∏è Instalando {pacote}...")
            try:
                subprocess.check_call([sys.executable, "-m", "pip", "install", "--user", pip_nome])
                print(f"‚úÖ {pacote} instalado com sucesso!")
            except subprocess.CalledProcessError as e:
                print(f"‚ùå Erro ao instalar {pacote}: {e}")
                print(f"üí° Tente instalar manualmente com: pip install --user {pip_nome}")
                sys.exit(1)
            except Exception as e:
                print(f"‚ùå Erro inesperado ao instalar {pacote}: {e}")
                sys.exit(1)

# Verificar depend√™ncias antes de importar
verificar_dependencias()

# Importar m√≥dulos ap√≥s verifica√ß√£o
import asyncio
import edge_tts
from pathlib import Path
import signal
from unidecode import unidecode
import re

# Try to import num2words, provide installation instructions if not found
try:
    from num2words import num2words
    print("‚úÖ num2words importado com sucesso!")
except ImportError:
    print("\n‚ùå Erro ao importar num2words. Tente instalar manualmente:")
    print("pip install --user num2words")
    sys.exit(1)

# Try to import langdetect, provide installation instructions if not found
try:
    from langdetect import detect, DetectorFactory
    DetectorFactory.seed = 0  # Set seed for consistent language detection
    LANG_DETECT_AVAILABLE = True
except ImportError:
    print("\n‚ö†Ô∏è The langdetect module is not installed.")
    print("To install it, run: pip install langdetect")
    LANG_DETECT_AVAILABLE = False

# Global flag for interruption
interruption_requested = False

# Function to validate Brazilian Portuguese text
def validar_texto_pt_br(texto):
    try:
        # Skip empty text
        if not texto.strip():
            print("\n‚ö†Ô∏è Aviso: O texto est√° vazio!")
            return False

        # Check if language detection is available
        if LANG_DETECT_AVAILABLE:
            try:
                idioma = detect(texto)
                if idioma != 'pt':
                    print(f"\n‚ö†Ô∏è Aviso: O texto pode n√£o estar em portugu√™s (idioma detectado: {idioma})")
                    print("Deseja continuar mesmo assim?")
                    print("[1] Sim")
                    print("[2] N√£o")
                    while True:
                        escolha = input("\nüîπ Sua escolha: ").strip()
                        if escolha in ['1', '2']:
                            return escolha == '1'
                        print("‚ö†Ô∏è Op√ß√£o inv√°lida! Tente novamente.")
            except Exception as e:
                print(f"\n‚ö†Ô∏è Aviso: N√£o foi poss√≠vel detectar o idioma automaticamente: {e}")
        else:
            print("\n‚ö†Ô∏è Aviso: A detec√ß√£o de idioma n√£o est√° dispon√≠vel.")
            print("Deseja continuar mesmo assim?")
            print("[1] Sim")
            print("[2] N√£o")
            while True:
                escolha = input("\nüîπ Sua escolha: ").strip()
                if escolha in ['1', '2']:
                    return escolha == '1'
                print("‚ö†Ô∏è Op√ß√£o inv√°lida! Tente novamente.")
        return True

    except Exception as e:
        print(f"\n‚ö†Ô∏è Erro ao verificar texto: {e}")
        print("Deseja continuar mesmo assim?")
        print("[1] Sim")
        print("[2] N√£o")
        while True:
            escolha = input("\nüîπ Sua escolha: ").strip()
            if escolha in ['1', '2']:
                return escolha == '1'
            print("‚ö†Ô∏è Op√ß√£o inv√°lida! Tente novamente.")

# Try to import googletrans for English to Portuguese translation
try:
    from googletrans import Translator
    TRANSLATOR_AVAILABLE = True
    translator = Translator()
except ImportError:
    print("\n‚ö†Ô∏è O m√≥dulo googletrans n√£o est√° instalado.")
    print("Para instalar, execute: pip install googletrans==3.1.0a0")
    TRANSLATOR_AVAILABLE = False

# Function to convert Roman numerals to decimal
def romano_para_decimal(romano):
    valores = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}
    decimal = 0
    prev_value = 0
    
    for char in reversed(romano.upper()):
        curr_value = valores.get(char, 0)
        if curr_value >= prev_value:
            decimal += curr_value
        else:
            decimal -= curr_value
        prev_value = curr_value
    return decimal

# Function to convert ordinal numbers to text
def converter_ordinal(match):
    numero = int(match.group(1))
    sufixo = match.group(2)
    if sufixo.lower() in ['¬∫', '¬™']:
        try:
            return num2words(numero, lang='pt_BR', ordinal=True)
        except:
            return match.group(0)
    return match.group(0)

# Function to optimize text for TTS
def otimizar_texto_tts(texto):
    # Traduzir texto do ingl√™s para portugu√™s se dispon√≠vel
    if TRANSLATOR_AVAILABLE:
        try:
            detected = translator.detect(texto)
            if detected.lang == 'en':
                texto = translator.translate(texto, dest='pt').text
                print("‚úÖ Texto traduzido do ingl√™s para portugu√™s")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro na tradu√ß√£o: {e}")
    
    # Converter algarismos romanos em cap√≠tulos e t√≠tulos
    texto = re.sub(r'(CAP√çTULO|Cap√≠tulo|T√çTULO|T√≠tulo|Parte|PARTE|Livro|LIVRO)\s+([IVXLCDM]+)', 
                   lambda m: f"{m.group(1)} {romano_para_decimal(m.group(2))}", 
                   texto)
    
    # Converter n√∫meros ordinais para texto (incluindo n√∫meros maiores)
    texto = re.sub(r'(\d+)([¬∫¬™])', converter_ordinal, texto)
    
    # Converter n√∫meros romanos isolados
    texto = re.sub(r'\b([IVXLCDM]+)\b', 
                   lambda m: str(romano_para_decimal(m.group(1))), 
                   texto)
    
    # Dicion√°rio expandido de palavras problem√°ticas
    palavras_problematicas = {
        # Acentos e pron√∫ncia
        'm√°s': 'mas', 'p√¥r': 'por', 't√™m': 'tem',
        '√†': 'a', '√†s': 'as', '√©': 'eh',
        'h√°': 'ha', 'atrav√©s': 'atraves',
        'ap√≥s': 'apos', 'at√©': 'ate',
        # N√∫meros por extenso para melhor pron√∫ncia
        '1¬∫': 'primeiro', '2¬∫': 'segundo', '3¬∫': 'terceiro',
        # Abrevia√ß√µes comuns
        'dr.': 'doutor', 'sr.': 'senhor', 'sra.': 'senhora',
        'prof.': 'professor', 'profa.': 'professora',
        # S√≠mbolos especiais
        '%': ' porcento', '&': ' e ',
        '@': ' arroba ', '#': ' hashtag ',
        # Melhorias de pron√∫ncia
        'pra': 'para', 'pro': 'para o',
        'vc': 'voc√™', 'tb': 'tamb√©m',
        'q': 'que', 'td': 'tudo'
    }
    
    # Otimizar texto para melhor pron√∫ncia
    texto = texto.lower()  # Converter para min√∫sculas para melhor correspond√™ncia
    
    # Substituir palavras problem√°ticas
    for original, corrigida in palavras_problematicas.items():
        # Usar regex para substituir palavras completas apenas
        texto = re.sub(f'\\b{original}\\b', corrigida, texto, flags=re.IGNORECASE)
    
    # Tratar n√∫meros
    texto = re.sub(r'\d+', lambda m: num2words(int(m.group()), lang='pt_BR'), texto)
    
    # Melhorar pausas em pontua√ß√£o
    sinais_pontuacao = {
        '.': '. ',   # Pausa longa
        ',': ', ',   # Pausa curta
        ';': '; ',   # Pausa m√©dia
        ':': ': ',   # Pausa m√©dia
        '!': '! ',   # √änfase
        '?': '? ',   # Entona√ß√£o de pergunta
        '...': '... ' # Pausa de retic√™ncias
    }
    
    # Aplicar pausas de pontua√ß√£o
    for sinal, substituicao in sinais_pontuacao.items():
        texto = texto.replace(sinal, substituicao)
    
    # Tratar retic√™ncias
    texto = re.sub(r'\.{3,}', '... ', texto)
    
    # Remover espa√ßos m√∫ltiplos e espa√ßos antes de pontua√ß√£o
    texto = re.sub(r'\s+', ' ', texto)  # Remover espa√ßos m√∫ltiplos
    texto = re.sub(r'\s+([.,!?;:])', r'\1', texto)  # Remover espa√ßos antes de pontua√ß√£o
    
    # Garantir espa√ßo ap√≥s pontua√ß√£o
    texto = re.sub(r'([.,!?;:])(?=\S)', r'\1 ', texto)
    
    return texto.strip()

# Function to handle SIGINT (Ctrl+C)
def signal_handler(signum, frame):
    global interruption_requested
    interruption_requested = True
    print("\n\nüõë Pressione Ctrl+C novamente para interromper a convers√£o...")

# Set up signal handler
signal.signal(signal.SIGINT, signal_handler)

# Function to handle interrupted conversion
async def handle_interruption(temp_files, arquivo_saida):
    print("\n\nüõë Convers√£o interrompida!")
    print("\nEscolha uma op√ß√£o:")
    print("[1] Manter arquivos parciais separados")
    print("[2] Unificar arquivos convertidos")
    print("[3] Excluir arquivos convertidos")
    
    while True:
        escolha = input("\nüîπ Sua escolha: ").strip()
        if escolha in ['1', '2', '3']:
            break
        print("‚ö†Ô∏è Op√ß√£o inv√°lida! Tente novamente.")
    
    if escolha == '1':
        print("\n‚úÖ Arquivos parciais mantidos separadamente.")
    
    elif escolha == '2':
        print("\nüîÑ Unificando arquivos convertidos...")
        try:
            with open(arquivo_saida, 'wb') as outfile:
                for temp_file in temp_files:
                    if os.path.exists(temp_file):
                        with open(temp_file, 'rb') as infile:
                            outfile.write(infile.read())
                        os.remove(temp_file)
            print("‚úÖ Arquivos unificados com sucesso!")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao unificar arquivos: {e}")
    
    else:  # escolha == '3'
        print("\nüóëÔ∏è Excluindo arquivos convertidos...")
        for temp_file in temp_files:
            try:
                if os.path.exists(temp_file):
                    os.remove(temp_file)
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao excluir {temp_file}: {e}")
        print("‚úÖ Arquivos exclu√≠dos com sucesso!")
    
    # Ask about keeping progress tracking
    progresso_file = f"{arquivo_saida}.progress"
    if os.path.exists(progresso_file):
        print("\nüíæ Deseja manter o registro de progresso para continuar a convers√£o posteriormente?")
        print("[1] Sim, manter registro de progresso")
        print("[2] N√£o, apagar registro de progresso")
        
        while True:
            escolha_progresso = input("\nüîπ Sua escolha: ").strip()
            if escolha_progresso in ['1', '2']:
                break
            print("‚ö†Ô∏è Op√ß√£o inv√°lida! Tente novamente.")
        
        if escolha_progresso == '2':
            try:
                os.remove(progresso_file)
                print("‚úÖ Registro de progresso apagado com sucesso!")
            except Exception as e:
                print(f"‚ö†Ô∏è Erro ao apagar registro de progresso: {e}")
        else:
            print("‚úÖ Registro de progresso mantido para continua√ß√£o posterior.")
    
    limpar_tela()
    return False

# =============================================================================
# Configura√ß√µes e Constantes
# =============================================================================
VOZES_PT_BR = [
    "pt-BR-ThalitaMultilingualNeural",  # Voz padr√£o
    "pt-BR-FranciscaNeural",
    "pt-BR-AntonioNeural"
]

# =============================================================================
# Fun√ß√µes Utilit√°rias
# =============================================================================
def limpar_tela():
    os.system("clear" if os.name == "posix" else "cls")

def exibir_menu():
    print("\n" + "="*60)
    print("""
    ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
    ‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
       ‚ñà‚ñà‚ïë      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
       ‚ñà‚ñà‚ïë      ‚ñà‚ñà‚ïë   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë
       ‚ñà‚ñà‚ïë      ‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë
       ‚ïö‚ïê‚ïù      ‚ïö‚ïê‚ïù   ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
    """)
    print("="*60)
    print("\n\033[1;36;1müéØ MENU PRINCIPAL\033[0m")
    print("-"*50)
    print("\n\033[1;32;1m[1] üöÄ INICIAR\033[0m")
    print("\033[1;34;1m[2] üéôÔ∏è VOZES\033[0m")
    print("\033[1;33;1m[3] ‚ùì AJUDA\033[0m")
    print("\033[1;31;1m[4] üö™ SAIR\033[0m")
    print("-"*50)
    while True:
        escolha = input("\n\033[1;36;1müîπ Escolha: \033[0m").strip()
        if escolha in ['1', '2', '3', '4']:
            return escolha
        print("\033[1;31;1m‚ö†Ô∏è Op√ß√£o inv√°lida!\033[0m")

def escolher_voz():
    print("\n\033[1;36;1müéôÔ∏è ESCOLHA A VOZ PARA A CONVERS√ÉO\033[0m")
    print("\n\033[1;33;1m‚≠ê A voz padr√£o √© 'Thalita' - otimizada para m√∫ltiplos idiomas\033[0m")
    for i, voz in enumerate(VOZES_PT_BR, start=1):
        if i == 1:
            print(f"\033[1;32;1m  [{i}] {voz}  (Voz padr√£o)\033[0m")
        else:
            print(f"\033[1;34;1m  [{i}] {voz}\033[0m")

    while True:
        escolha = input("\n\033[1;36;1müîπ Digite o n√∫mero da voz desejada: \033[0m").strip()
        if escolha.isdigit() and 1 <= int(escolha) <= len(VOZES_PT_BR):
            return VOZES_PT_BR[int(escolha) - 1]
        print("\033[1;31;1m‚ö†Ô∏è Op√ß√£o inv√°lida! Escolha um n√∫mero da lista.\033[0m")

def exibir_ajuda():
    print("\n" + "-"*50)
    print("\033[1;36;1müìö GUIA DO CONVERSOR TTS\033[0m")
    print("-"*50)
    print("\n\033[1;33;1m1Ô∏è‚É£ PREPARA√á√ÉO\033[0m")
    print("\033[1;37;1m‚Ä¢ Salve texto em .txt\033[0m")
    print("\033[1;37;1m‚Ä¢ Coloque na Downloads\033[0m")
    
    print("\n\033[1;33;1m2Ô∏è‚É£ CONVERS√ÉO\033[0m")
    print("\033[1;37;1m‚Ä¢ Selecione 'Iniciar'\033[0m")
    print("\033[1;37;1m‚Ä¢ Escolha o arquivo\033[0m")
    print("\033[1;37;1m‚Ä¢ Selecione a voz\033[0m")
    
    print("\n\033[1;33;1m3Ô∏è‚É£ RECURSOS\033[0m")
    print("\033[1;37;1m‚Ä¢ N√∫meros para texto\033[0m")
    print("\033[1;37;1m‚Ä¢ Otimiza√ß√£o PT-BR\033[0m")
    print("\033[1;37;1m‚Ä¢ Textos longos\033[0m")
    print("\033[1;37;1m‚Ä¢ Detec√ß√£o de idioma\033[0m")
    
    print("\n\033[1;33;1m4Ô∏è‚É£ DICAS\033[0m")
    print("\033[1;37;1m‚Ä¢ Teste as vozes\033[0m")
    print("\033[1;37;1m‚Ä¢ Use Ctrl+C p/ parar\033[0m")
    print("\033[1;37;1m‚Ä¢ √Åudio na Downloads\033[0m")
    
    print("\n\033[1;33;1m5Ô∏è‚É£ FORMATOS\033[0m")
    print("\033[1;37;1m‚Ä¢ N√∫meros ordinais\033[0m")
    print("\033[1;37;1m‚Ä¢ N√∫meros romanos\033[0m")
    print("\033[1;37;1m‚Ä¢ Abrevia√ß√µes\033[0m")
    print("\033[1;37;1m‚Ä¢ S√≠mbolos especiais\033[0m")
    
    input("\n\033[1;36;1müîπ Pressione Enter para voltar...\033[0m")
    limpar_tela()

def escolher_voz():
    print("\n" + "-"*50)
    print("\033[1;36;1müéôÔ∏è ESCOLHA A VOZ PARA A CONVERS√ÉO\033[0m")
    print("\n\033[1;33;1m‚≠ê A voz padr√£o √© 'Thalita' - otimizada para m√∫ltiplos idiomas\033[0m")
    for i, voz in enumerate(VOZES_PT_BR, start=1):
        if i == 1:
            print(f"\033[1;32;1m  [{i}] {voz}  (Voz padr√£o)\033[0m")
        else:
            print(f"\033[1;34;1m  [{i}] {voz}\033[0m")

    while True:
        escolha = input("\n\033[1;36;1müîπ Digite o n√∫mero da voz desejada: \033[0m").strip()
        if escolha.isdigit() and 1 <= int(escolha) <= len(VOZES_PT_BR):
            return VOZES_PT_BR[int(escolha) - 1]
        print("\033[1;31;1m‚ö†Ô∏è Op√ß√£o inv√°lida! Escolha um n√∫mero da lista.\033[0m")

# =============================================================================
# Fun√ß√µes de Processamento
# =============================================================================
def ler_arquivo(caminho):
    try:
        with open(caminho, 'r', encoding='utf-8') as f:
            return f.read()
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao ler arquivo: {e}")
        return None

async def processar_audio(texto, arquivo_saida, voz, chunk_size=2000):
    try:
        # Initialize temp_files list at the beginning of the function
        temp_files = []
        # Get first line for file naming
        primeira_linha = texto.strip().split('\n')[0].strip()
        if primeira_linha:
            nome_base = Path(arquivo_saida).parent / primeira_linha
            arquivo_saida = f"{nome_base}.mp3"

        # Ask for file unification preference
        print("\nüì¶ Prefer√™ncia de arquivos:")
        print("[Enter/N] Unificar arquivos e excluir partes (padr√£o)")
        print("[S] Manter arquivos separados")
        escolha = input("\nüîπ Sua escolha: ").strip().upper()
        manter_separado = escolha == 'S'

        # Validate text language
        if not validar_texto_pt_br(texto):
            print("\nüõë Convers√£o cancelada pelo usu√°rio.")
            return False

        # Optimize text for better pronunciation
        texto = otimizar_texto_tts(texto)

        # Reset interruption flag
        global interruption_requested
        interruption_requested = False

        # Otimizar o tamanho dos chunks e buffer para melhor performance
        chunk_size = max(2000, min(len(texto) // 10, 5000))  # Chunks adaptativos
        partes = [texto[i:i+chunk_size] for i in range(0, len(texto), chunk_size)]
        total_partes = len(partes)
        temp_files = []
        buffer_size = 32768  # Buffer maior para I/O mais eficiente

        print(f"\nüîÑ Processando {total_partes} partes...")
        print("\nPressione Ctrl+C para interromper a convers√£o a qualquer momento.")

        # Carregar progresso anterior se existir
        progresso_file = f"{arquivo_saida}.progress"
        ultima_parte = 0
        if os.path.exists(progresso_file):
            try:
                with open(progresso_file, 'r') as f:
                    ultima_parte = int(f.read().strip())
                print(f"\nüìù Retomando da parte {ultima_parte + 1}")
            except:
                ultima_parte = 0

        for i, parte in enumerate(partes[ultima_parte:], ultima_parte + 1):
            if interruption_requested:
                # Salvar progresso antes de interromper
                with open(progresso_file, 'w') as f:
                    f.write(str(i - 1))
                await handle_interruption(temp_files, arquivo_saida)
                limpar_tela()
                return False

            print(f"\rüìä Progresso: {i}/{total_partes} ({int(i/total_partes*100)}%)" + "="*(i*20//total_partes) + ">", end="")
            
            # Processar texto em lotes para reduzir chamadas √† API
            max_tentativas = 5
            tentativa = 0
            while tentativa < max_tentativas:
                try:
                    communicate = edge_tts.Communicate(parte.strip(), voz)
                    arquivo_temp = f"{arquivo_saida}.part{i:03d}.mp3"
                    await communicate.save(arquivo_temp)
                    temp_files.append(arquivo_temp)
                    # Salvar progresso ap√≥s sucesso
                    with open(progresso_file, 'w') as f:
                        f.write(str(i))
                    break
                except Exception as e:
                    tentativa += 1
                    if tentativa < max_tentativas:
                        tempo_espera = 2 ** tentativa  # Backoff exponencial
                        print(f"\n‚ö†Ô∏è Erro ao processar parte {i}. Tentativa {tentativa}/{max_tentativas}. Aguardando {tempo_espera}s...")
                        await asyncio.sleep(tempo_espera)
                    else:
                        print(f"\n‚ö†Ô∏è Erro ao processar parte {i} ap√≥s {max_tentativas} tentativas: {e}")
                        continue

        # Handle files based on user preference
        if not interruption_requested:
            if not manter_separado:
                print("\nüì¶ Combinando arquivos...")
                # Otimizar a combina√ß√£o dos arquivos com buffer maior e verifica√ß√£o de mem√≥ria
                with open(arquivo_saida, 'wb') as outfile:
                    for temp_file in temp_files:
                        if not os.path.exists(temp_file):
                            continue
                        try:
                            with open(temp_file, 'rb') as infile:
                                while True:
                                    chunk = infile.read(buffer_size)
                                    if not chunk:
                                        break
                                    outfile.write(chunk)
                                    outfile.flush()  # Garantir que os dados sejam escritos
                            # Close the file before attempting to remove it
                            infile.close()
                            if os.path.exists(temp_file):
                                try:
                                    os.remove(temp_file)  # Remover arquivo tempor√°rio ap√≥s uso
                                    print(f"\rüóëÔ∏è Arquivo tempor√°rio removido: {temp_file}", end="")
                                except Exception as e:
                                    print(f"\n‚ö†Ô∏è Erro ao excluir arquivo tempor√°rio {temp_file}: {e}")
                        except Exception as e:
                            print(f"\n‚ö†Ô∏è Erro ao processar arquivo tempor√°rio {temp_file}: {e}")
                            continue
                # Remover arquivo de progresso ap√≥s conclus√£o
                if os.path.exists(progresso_file):
                    try:
                        os.remove(progresso_file)
                    except Exception as e:
                        print(f"\n‚ö†Ô∏è Erro ao excluir arquivo de progresso: {e}")
                print("\n‚úÖ Convers√£o conclu√≠da! Arquivo unificado criado.")
            else:
                print("\n‚úÖ Convers√£o conclu√≠da! Arquivos mantidos separados.")
            return True

    except Exception as e:
        print(f"\n‚ö†Ô∏è Erro durante o processamento: {e}")
        # Limpar arquivos tempor√°rios em caso de erro
        for temp_file in temp_files:
            try:
                if os.path.exists(temp_file):
                    os.remove(temp_file)
            except:
                pass
        return False

# =============================================================================
# Fun√ß√µes Principais
# =============================================================================
async def converter_audio():
    limpar_tela()
    print("\nüìñ Conversor de Texto para Fala - Modo Leve\n")

    # Diret√≥rio padr√£o para arquivos TXT no Android
    diretorio_padrao = "/storage/emulated/0/Download"
    if not os.path.exists(diretorio_padrao):
        diretorio_padrao = os.path.expanduser("~/storage/downloads")  # Fallback para Termux
        if not os.path.exists(diretorio_padrao):
            diretorio_padrao = os.path.expanduser("~")  # √öltimo fallback

    try:
        # Verificar se o diret√≥rio existe e tem permiss√£o de acesso
        if not os.path.exists(diretorio_padrao):
            print(f"‚ö†Ô∏è Diret√≥rio n√£o encontrado: {diretorio_padrao}")
            print("‚ÑπÔ∏è Dica: Verifique se o Termux tem permiss√£o de acesso ao armazenamento.")
            print("   Execute: termux-setup-storage")
            return

        # Listar arquivos TXT no diret√≥rio
        arquivos_txt = [f for f in os.listdir(diretorio_padrao) if f.endswith('.txt')]

        if not arquivos_txt:
            print("‚ö†Ô∏è Nenhum arquivo TXT encontrado no diret√≥rio de downloads!")
            return

        # Exibir lista de arquivos dispon√≠veis
        print("üìÑ Arquivos TXT dispon√≠veis:")
        for i, arquivo in enumerate(arquivos_txt, 1):
            print(f"[{i}] {arquivo}")

        # Selecionar arquivo
        while True:
            escolha = input("\nüîπ Digite o n√∫mero do arquivo desejado: ").strip()
            if escolha.isdigit() and 1 <= int(escolha) <= len(arquivos_txt):
                arquivo_selecionado = arquivos_txt[int(escolha) - 1]
                break
            print("‚ö†Ô∏è Op√ß√£o inv√°lida! Escolha um n√∫mero da lista.")

        caminho_completo = os.path.join(diretorio_padrao, arquivo_selecionado)
        print(f"\nüìÑ Lendo arquivo: {arquivo_selecionado}")
        texto = ler_arquivo(caminho_completo)
        if not texto:
            return

        voz = escolher_voz()
        nome_base = Path(caminho_completo).stem
        diretorio_saida = os.path.join(diretorio_padrao, f"{nome_base}_audio")
        os.makedirs(diretorio_saida, exist_ok=True)

        arquivo_saida = os.path.join(diretorio_saida, f"{nome_base}.mp3")
        await processar_audio(texto, arquivo_saida, voz)
        print(f"\nüìÇ Arquivos salvos em: {diretorio_saida}")

    except Exception as e:
        print(f"\n‚ö†Ô∏è Erro: {e}")

    input("\nüîπ Pressione Enter para voltar ao menu...")
    limpar_tela()

async def testar_vozes():
    limpar_tela()
    print("\nüîä Gerando arquivos de teste para cada voz...\n")

    diretorio_testes = "vozes_teste"
    os.makedirs(diretorio_testes, exist_ok=True)

    texto_teste = "Este √© um teste da voz para convers√£o de texto em fala."
    for voz in VOZES_PT_BR:
        print(f"\nüéôÔ∏è Testando voz: {voz}")
        arquivo_mp3 = os.path.join(diretorio_testes, f"{voz}.mp3")
        communicate = edge_tts.Communicate(texto_teste, voz)
        await communicate.save(arquivo_mp3)
        print(f"‚úÖ Arquivo salvo: {arquivo_mp3}")

    print("\n‚úÖ Testes conclu√≠dos!")
    print(f"üìÇ Arquivos salvos em: {diretorio_testes}")
    input("\nüîπ Pressione Enter para voltar ao menu...")
    limpar_tela()

# =============================================================================
# Fun√ß√£o Principal
# =============================================================================
async def main():
    while True:
        escolha = exibir_menu()
        if escolha == '1':
            await converter_audio()
        elif escolha == '2':
            await testar_vozes()
        elif escolha == '3':
            exibir_ajuda()
        else:  # escolha == '4'
            print("\nüëã Obrigado por usar o Conversor TTS Lite!")
            break

if __name__ == '__main__':
    asyncio.run(main())